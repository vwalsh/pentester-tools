import {
  IconButton,
  InputAdornment,
  TextField,
  TextFieldProps,
} from '@mui/material'
import React, { useCallback, useEffect, useRef } from 'react'
import { useComputed, useSignal } from '@preact/signals-react'
import CloseIcon from '@mui/icons-material/Close'
import { disablePageScrolling, enablePageScrolling } from '../../utils'

interface Props {
  props: TextFieldProps
  numberChangeEvent: (n: number) => void
  defaultValue: number
  disabled?: boolean
}

const NumberInput = React.memo(
  ({ props, numberChangeEvent, defaultValue, disabled }: Props) => {
    const inputRef = useRef<HTMLElement | null>(null)
    const tmpVal = useSignal<number | string>(defaultValue)
    const error = useSignal<string>('')

    const checkWithinRange = useCallback(
      (n: number) => {
        // Test if the n is >= min and <= Max

        const minRange = props.InputProps?.inputProps?.min
        const maxRange = props.InputProps?.inputProps?.max

        // console.log({minRange, maxRange})

        if (isNaN(n)) {
          return false
        }

        if (minRange === undefined && maxRange !== undefined) {
          // max range set, ensure it's <= than the max
          return n <= maxRange
        } else if (minRange !== undefined && maxRange === undefined) {
          // min range set, ensure it's >= than the min
          return n >= minRange
        } else if (minRange === undefined && maxRange === undefined) {
          return true // no range set, must be within range
        } else {
          // max and min range are defined
          return n >= minRange && n <= maxRange
        }
      },
      [props]
    )

    const updateValue = useCallback(
      (val: number | string) => {
        const tmp = parseInt(val.toString())

        if (isNaN(tmp)) {
          // this stops the user from shooting themselves in the foot.
          error.value = 'Only Positive or Negative integers are allowed'
          tmpVal.value = val.toString()

          return
        }

        if (checkWithinRange(tmp) === false) {
          error.value = 'Only values within the Min and Max range are allowed'
          tmpVal.value = tmp
          return
        }

        error.value = ''
        numberChangeEvent(tmp)
        tmpVal.value = tmp
      },
      [checkWithinRange, error, numberChangeEvent, tmpVal]
    )

    const customProps = useComputed(() => {
      const tmp = props
      tmp.InputProps = {
        ...props.InputProps,
        endAdornment: (
          <InputAdornment position="end">
            <IconButton
              tabIndex={-1}
              title={`reset to default: ${defaultValue}`}
              disabled={disabled}
              onClick={() => {
                error.value = ''
                tmpVal.value = defaultValue
                numberChangeEvent(defaultValue)
              }}
            >
              <CloseIcon color="error" />
            </IconButton>
          </InputAdornment>
        ),
      }

      return tmp
    })

    useEffect(() => {
      if (typeof props.value === 'number') {
        tmpVal.value = props.value
      }
    }, [props.value, tmpVal])

    useEffect(() => {
      const tmp = parseInt(tmpVal.value.toString())

      if (isNaN(tmp) === false && checkWithinRange(tmp) === false) {
        error.value = 'Only values within the Min and Max range are allowed'
        // tmpVal.value = tm
        return
      }

      error.value = ''

      if (props.value !== tmp) {
        numberChangeEvent(tmp)
      }
    }, [props, tmpVal, checkWithinRange, error, numberChangeEvent])

    return (
      <TextField
        type="number"
        error={error.value !== ''}
        color={
          disabled === false && disabled !== undefined ? 'success' : 'primary'
        }
        disabled={disabled}
        focused={
          disabled === false && disabled !== undefined ? true : undefined
        }
        helperText={error.value}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          updateValue(event.target.value)
        }}
        // all of the following events for element focusing are to ensure that the
        //  entire web page gets re-enabled to scroll
        onFocus={(event) => {
          if (event.currentTarget.nodeName.toLowerCase() === 'input') {
            inputRef.current = event.currentTarget
          } else if (event.currentTarget.querySelector('input') !== null) {
            inputRef.current = event.currentTarget.querySelector('input')
          }

          event.target.select()

          disablePageScrolling()
        }}
        onKeyDown={(event) => {
          if (inputRef.current === undefined || inputRef.current === null) {
            inputRef.current = event.currentTarget.querySelector('input')
          }

          // TODO: consider resetting to default on escape press if out of range?

          if (
            event.code.toLowerCase() === 'tab' ||
            event.code.toLowerCase() === 'escape'
          ) {
            enablePageScrolling(inputRef.current)
          }
        }}
        onBlur={() => {
          enablePageScrolling(inputRef.current)
        }}
        onMouseLeave={() => {
          enablePageScrolling(inputRef.current)
        }}
        // the custom props applied
        {...customProps.value}
        value={tmpVal.value}
        label={`${props.label} (${
          props.InputProps?.inputProps?.min === undefined
            ? 'no min'
            : props.InputProps?.inputProps?.min
        } to ${
          props.InputProps?.inputProps?.max === undefined
            ? 'no max'
            : props.InputProps?.inputProps?.max
        })`}
      />
    )
  }
)

export default NumberInput
