import {
  IconButton,
  InputAdornment,
  TextField,
  TextFieldProps,
} from '@mui/material'
import React, { useEffect, useRef } from 'react'
import { useComputed, useSignal } from '@preact/signals-react'
import CloseIcon from '@mui/icons-material/Close'

interface Props {
  props: TextFieldProps
  numberChangeEvent: (n: number) => void
  defaultValue: number
  disabled?: boolean
}

// plain js function to get the scroll bar width of the browser.
function getScrollBarWidth() {
  const el = document.createElement('div')
  el.style.cssText = 'overflow:scroll; visibility:hidden; position:absolute;'
  document.body.appendChild(el)
  const width = el.offsetWidth - el.clientWidth
  el.remove()
  return width
}

// plain js function to check if the scrollbar is visible for the provided element.
// using the html element it can be determined if the scrollbar is shown
function scrollbarVisible(element: HTMLElement) {
  return element.scrollHeight > element.clientHeight
}

function disablePageScrolling() {
  // disables the entire page scrolling temporarily.
  // this is to enable scrolling within the Number Input to change the value of a number input while disabling scroll for the rest of the web page!
  const htmlElem = document.getElementsByTagName('html')[0]
  const htmlStyle = htmlElem.style
  const bodyStyle = document.getElementsByTagName('body')[0].style
  bodyStyle.overflow = 'hidden'
  htmlStyle.overflow = 'hidden'

  if (
    navigator.userAgent.toLowerCase().indexOf('chrome') > -1 &&
    scrollbarVisible(htmlElem)
  ) {
    // NOTE: in Firefox, the scrollbar isn't this size so apply this ONLY to chrome
    bodyStyle.paddingRight = `${scrollBarWidth}px`
  }
}

function enablePageScrolling(elem: HTMLElement | null) {
  // this enables the entire web page to scroll again when the user is done with this number input
  // these are the CSS defaults for these properties
  const htmlStyle = document.getElementsByTagName('html')[0].style
  const bodyStyle = document.getElementsByTagName('body')[0].style
  bodyStyle.overflow = 'visible'
  htmlStyle.overflow = 'visible'
  bodyStyle.paddingRight = ''
  elem?.blur()
}

const scrollBarWidth = getScrollBarWidth()

const NumberInput = React.memo(
  ({ props, numberChangeEvent, defaultValue, disabled }: Props) => {
    const inputRef = useRef<HTMLElement | null>(null)
    const tmpVal = useSignal<number>(defaultValue)
    const error = useSignal<boolean>(false)

    const customProps = useComputed(() => {
      const tmp = props
      tmp.InputProps = {
        ...props.InputProps,
        endAdornment: (
          <InputAdornment position="end">
            <IconButton
              tabIndex={-1}
              title={`reset to default: ${defaultValue}`}
              disabled={disabled}
              onClick={() => {
                tmpVal.value = defaultValue
                numberChangeEvent(defaultValue)
              }}
            >
              <CloseIcon color="error" />
            </IconButton>
          </InputAdornment>
        ),
      }

      return tmp
    })

    useEffect(() => {
      if (typeof props.value === 'number') {
        tmpVal.value = props.value
      }
    }, [props.value, tmpVal])

    return (
      <TextField
        type="number"
        error={error.value}
        color={
          disabled === false && disabled !== undefined ? 'success' : 'primary'
        }
        disabled={disabled}
        focused={
          disabled === false && disabled !== undefined ? true : undefined
        }
        helperText={error.value === true ? 'Only numbers are allowed' : ''}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          const tmp = parseInt(event.target.value)

          if (isNaN(tmp)) {
            // this stops the user from shooting themselves in the foot.
            error.value = true
            return
          }

          error.value = false
          numberChangeEvent(tmp)
          tmpVal.value = tmp
        }}
        // all of the following events for element focusing are to ensure that the
        //  entire web page gets re-enabled to scroll
        onFocus={(event) => {
          if (event.currentTarget.nodeName.toLowerCase() === 'input') {
            inputRef.current = event.currentTarget
          } else if (event.currentTarget.querySelector('input') !== null) {
            inputRef.current = event.currentTarget.querySelector('input')
          }

          disablePageScrolling()
        }}
        onKeyDown={(event) => {
          if (inputRef.current === undefined || inputRef.current === null) {
            inputRef.current = event.currentTarget.querySelector('input')
          }

          if (
            event.code.toLowerCase() === 'tab' ||
            event.code.toLowerCase() === 'escape'
          ) {
            enablePageScrolling(inputRef.current)
          }
        }}
        onBlur={() => {
          enablePageScrolling(inputRef.current)
        }}
        onMouseLeave={() => {
          enablePageScrolling(inputRef.current)
        }}
        // the custom props applied
        {...customProps.value}
        value={tmpVal.value}
      />
    )
  }
)

export default NumberInput
