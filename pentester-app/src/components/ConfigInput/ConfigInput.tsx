import { useSignal } from '@preact/signals-react'
import { Checkbox, FormControlLabel, FormGroup, TextField } from '@mui/material'
import { useContext } from 'react'
import { AppState } from '../../pages/Home/Home'
import React from 'react'

export interface CMDConfigProps {
  help: string
  replace: string
  defaultValue: number | string
  props: InputProps
}

export interface CMDProps {
  win: number
  label: string
  platform: 'windows' | 'linux' | 'linux|windows'
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>
  cmd: string
  config?: Array<CMDConfigProps>
  allowTerminalWrap: boolean
  code?: Array<{
    filename: string
    data: string
  }>
}

interface InputProps {
  type: 'number' | 'string' | 'checkbox'
  label: string
  replaceValue?: string
  InputProps?: { inputProps: { min?: number; max?: number } }
}

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number
}

const ConfigInput = React.memo(({ cfg, defaultValue }: ConfigInputProps) => {
  const { setReplacements } = useContext(AppState)

  // console.log('defaultvalue', cfg.props.label, defaultValue)

  const NumberOrTextInput = React.memo(() => {
    const val = useSignal<number | string>(defaultValue)

    if (cfg.props.type !== 'number' && cfg.props.type !== 'string') {
      return <></>
    }
    return (
      <TextField
        onFocusCapture={() => {
          // this is to enable scrolling to change the value of a number input while disabling scroll for the rest of the web page!
          const htmlStyle = document.getElementsByTagName('html')[0].style
          const bodyStyle = document.getElementsByTagName('body')[0].style
          bodyStyle.overflow = 'hidden'
          htmlStyle.overflow = 'hidden'
        }}
        onMouseLeave={(event) => {
          // this enables the whole web page to scroll again when the user is done with this number input
          const htmlStyle = document.getElementsByTagName('html')[0].style
          const bodyStyle = document.getElementsByTagName('body')[0].style
          bodyStyle.overflow = 'visible'
          htmlStyle.overflow = 'visible'

          event.currentTarget.querySelector('input')?.blur()
        }}
        fullWidth
        {...cfg.props}
        value={val}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          if (cfg.props.type === 'number') {
            setReplacements({
              name: cfg.replace,
              value: parseInt(event.target.value),
            })
            val.value = parseInt(event.target.value)
          } else if (cfg.props.type === 'string') {
            val.value = event.target.value
            setReplacements({
              name: cfg.replace,
              value: event.target.value,
            })
          }
        }}
      />
    )
  })

  const CheckboxInput = React.memo(() => {
    const checkboxChecked = useSignal<boolean>(!!defaultValue)

    if (cfg.props.type !== 'checkbox') {
      return <></>
    }

    return (
      <FormGroup>
        <FormControlLabel
          sx={{ userSelect: 'none' }}
          control={
            <Checkbox
              inputProps={{ 'aria-label': cfg.props.label }}
              checked={checkboxChecked.value}
              onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                console.log('checkbox', event.target.checked)
                checkboxChecked.value = event.target.checked
                let replVal =
                  cfg.props.replaceValue === undefined
                    ? ''
                    : cfg.props.replaceValue
                if (event.target.checked === false) {
                  replVal = ''
                }
                setReplacements({
                  name: cfg.replace,
                  value: replVal,
                })
              }}
            />
          }
          label={cfg.props.label}
        />
      </FormGroup>
    )
  })

  return (
    <>
      <NumberOrTextInput />
      <CheckboxInput />
    </>
  )
})

export default ConfigInput
