import { useSignal } from '@preact/signals-react'
import {
  Autocomplete,
  Checkbox,
  FormControlLabel,
  FormGroup,
  TextField,
} from '@mui/material'
import { useContext, useEffect } from 'react'
import { AppState } from '../../pages/Home/Home'
import React from 'react'

export interface CMDProps {
  // the window number for this command. if a command has the same window number as another command,
  // it will replace the command at that window number.
  win: number

  // the name of this command. if this is specific to a given platform consider including that in the label
  //  so the user can understand if this is intended for windows or linux easily. reduces ambiguity
  label: string

  // TODO: consider adding a DESCRIPTION string so that each command can have a little info icon button to show some basic
  // info about the command and it's purpose

  // what platform is this command intended to run on?
  platform: 'windows' | 'linux' | 'linux|windows'

  // the type of terminal this command could run in. currently UNUSED
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>

  // the command with the replacement values in the order necessary to work properly
  cmd: string

  // the various custom inputs for this given command
  config?: Array<CMDConfigProps>

  // can this command be wrapped with spawning options like powershell base64 encoding?
  allowTerminalWrap: boolean

  // is there any code that is included with this command? it should be base64 encoded or it won't work properly
  code?: Array<{
    filename: string
    data: string
  }>
}

interface CMDConfigProps {
  // a more detailed help string displayed in when the info button is clicked
  help: string
  // the string to replace within the command typically follows the pattern of '__NAME__'
  replace: string

  // the default value to start with when replacing the above replace string property
  defaultValue: number | string | boolean

  // validation regex to check if the value matches expected patterns
  validationRegex?: string

  // display this text when the user fills in the field incorrectly
  validationHelp?: string

  // props to apply to the various component types
  props:
    | NumberInputProps
    | StringInputProps
    | CheckboxInputProps
    | SelectInputProps
}

interface DefaultInputProps {
  type: string

  // typical label (eg text string to describe/title something)
  label: string
}

interface NumberInputProps extends DefaultInputProps {
  type: 'number'

  // allows for a min and max size number to be created
  InputProps?: { inputProps: { min?: number; max?: number } }
}

interface StringInputProps extends DefaultInputProps {
  type: 'string'
}

interface CheckboxInputProps extends DefaultInputProps {
  type: 'checkbox'

  //  allows for the value to be replaced as this string when the checkbox is checked/true
  replaceValue: string
}

interface SelectInputProps extends DefaultInputProps {
  type: 'select'

  // dropdown options array of strings
  options: Array<string>

  // allow the user to enter custom values besides the 'options' array
  customInput: boolean
}

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number | boolean
}

const ConfigInput = React.memo(({ cfg, defaultValue }: ConfigInputProps) => {
  const { setReplacements } = useContext(AppState)

  // ================================================================
  // string/text input

  interface StringInputCompProps {
    cfg: CMDConfigProps
    props: StringInputProps
    defaultValue: string
  }
  const StringInput = React.memo(
    ({ cfg, props, defaultValue }: StringInputCompProps) => {
      const val = useSignal<string>(defaultValue)
      const validationError = useSignal<boolean>(false)

      useEffect(() => {
        if (cfg.props.type !== 'string') {
          return
        }

        setReplacements({
          name: cfg.replace,
          value: defaultValue,
        })
      })

      if (cfg.props.type !== 'string') {
        return <></>
      }
      return (
        <TextField
          fullWidth
          {...props}
          value={val}
          error={validationError.value}
          helperText={validationError.value === true ? cfg.validationHelp : ''}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            // validate if the validationRegex exists
            if (
              cfg.validationRegex !== undefined &&
              cfg.validationRegex !== ''
            ) {
              const re = new RegExp(cfg.validationRegex)

              validationError.value = !re.test(event.target.value)
            }

            val.value = event.target.value
            setReplacements({
              name: cfg.replace,
              value: event.target.value,
            })
          }}
        />
      )
    }
  )

  // ================================================================
  // number input
  const NumberInput = React.memo(() => {
    const val = useSignal<number>(parseInt(defaultValue.toString()))

    if (cfg.props.type !== 'number') {
      return <></>
    }
    return (
      <TextField
        onFocusCapture={() => {
          // this is to enable scrolling to change the value of a number input while disabling scroll for the rest of the web page!
          const htmlStyle = document.getElementsByTagName('html')[0].style
          const bodyStyle = document.getElementsByTagName('body')[0].style
          bodyStyle.overflow = 'hidden'
          htmlStyle.overflow = 'hidden'
        }}
        onMouseLeave={(event) => {
          // this enables the whole web page to scroll again when the user is done with this number input
          const htmlStyle = document.getElementsByTagName('html')[0].style
          const bodyStyle = document.getElementsByTagName('body')[0].style
          bodyStyle.overflow = 'visible'
          htmlStyle.overflow = 'visible'

          event.currentTarget.querySelector('input')?.blur()
        }}
        fullWidth
        {...cfg.props}
        value={val}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          setReplacements({
            name: cfg.replace,
            value: parseInt(event.target.value),
          })
          val.value = parseInt(event.target.value)
        }}
      />
    )
  })

  // ================================================================
  // checkbox component
  interface CheckboxProps {
    cfg: CMDConfigProps
    props: CheckboxInputProps
    defaultValue: boolean
  }
  const CheckboxInput = React.memo(
    ({ cfg, props, defaultValue }: CheckboxProps) => {
      const checkboxChecked = useSignal<boolean>(defaultValue)

      useEffect(() => {
        // run this once
        if (props.type !== 'checkbox') {
          return
        }

        setReplacements({
          name: cfg.replace,
          value: checkboxChecked.value === false ? '' : props.replaceValue,
        })
      })

      if (props.type !== 'checkbox') {
        return <></>
      }

      return (
        <FormGroup>
          <FormControlLabel
            sx={{ userSelect: 'none' }}
            control={
              <Checkbox
                inputProps={{ 'aria-label': props.label }}
                checked={checkboxChecked.value}
                onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                  checkboxChecked.value = event.target.checked
                  let replVal =
                    props.replaceValue === undefined ? '' : props.replaceValue
                  if (event.target.checked === false) {
                    replVal = ''
                  }
                  setReplacements({
                    name: cfg.replace,
                    value: replVal,
                  })
                }}
              />
            }
            label={cfg.props.label}
          />
        </FormGroup>
      )
    }
  )

  // ================================================================
  // select from a list of options
  const SelectOptions = React.memo(() => {
    const optionSelected = useSignal<string>(defaultValue.toString())

    useEffect(() => {
      if (cfg.props.type !== 'select') {
        return
      }

      // run this once
      setReplacements({
        name: cfg.replace,
        value: optionSelected.value,
      })
    })

    if (cfg.props.type !== 'select') {
      return <></>
    }

    return (
      <>
        <Autocomplete
          freeSolo={cfg.props.customInput}
          disablePortal
          id={`omni-${cfg.replace}`}
          options={cfg.props.options}
          sx={{ width: 300 }}
          renderInput={(params) => (
            <TextField {...params} label={cfg.props.label} />
          )}
          value={optionSelected.value}
          onChange={(_event: React.SyntheticEvent, newValue: string | null) => {
            if (newValue === null) {
              optionSelected.value = ''
              return
            }
            optionSelected.value = newValue
          }}
          // isOptionEqualToValue={function (
          //   option: TermsProps,
          //   value: TermsProps
          // ) {
          //   if (option.label === value.label) {
          //     return true
          //   }

          //   return false
          // }}
        />
      </>
    )
  })

  return (
    <>
      <NumberInput />
      <StringInput
        cfg={cfg}
        props={cfg.props as StringInputProps}
        defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
      />
      <CheckboxInput
        cfg={cfg}
        props={cfg.props as CheckboxInputProps}
        defaultValue={typeof defaultValue === 'boolean' ? defaultValue : false}
      />
      <SelectOptions />
    </>
  )
})

export default ConfigInput
