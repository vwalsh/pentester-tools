import useGlobalStore from '../../hooks/useGlobalStore'

import Commands from '../../assets/commands.json'
import Files from '../../assets/dirtree.json'

import { useCallback, useEffect, useMemo, useState } from 'react'
import {
  Autocomplete,
  Box,
  Button,
  Grid,
  IconButton,
  List,
  ListItem,
  TextField,
  Typography,
} from '@mui/material'
import CloudDownloadIcon from '@mui/icons-material/CloudDownload'
import CopyItem from '../CopyItem'

interface CMDProps {
  win: number
  label: string
  platform: 'windows' | 'linux' | 'linux|windows'
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>
  cmd: string
  allowTerminalWrap: boolean
  code?: Array<{
    filename: string
    data: string
  }>
}

interface CommandsProps {
  id: string
  keywords: Array<string>
  cmds: Array<CMDProps>
}

interface TerminalProps {
  term: string
  cmd: string
}

function CommandConfigurator() {
  const {
    ahost,
    aport,
    search,
    httpFile,
    setHTTPFile,
    fileSearchEnabled,
    setFileSearchEnabled,
    terminalWrap,
    setTerminalWrap
  } = useGlobalStore()

  const [command_windows, setCommand_windows] = useState<Array<CMDProps>>()

  const CommandWrap: Array<TerminalProps> = [
    { term: 'Powershell -c', cmd: `powershell -c '__CMD__'` },
    { term: 'PS Prompt', cmd: `__CMD__` },
    { term: 'PS.exe -c', cmd: `C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe  '__CMD__'` },
    { term: 'CMD in PS Prompt', cmd: `cmd /r '__CMD__'` },
    { term: '/bin/sh -c', cmd: `/bin/sh -c '__CMD__'` },
    { term: '/bin/bash -c', cmd: `/bin/bash -c '__CMD__'` },
  ]

  const download_file = useCallback((filename: string, b64data: string) => {
    // console.log('todo: implement this download!', filename, atob(b64data))
    const data = new Blob([atob(b64data)], { type: 'text' })
    const csvURL = window.URL.createObjectURL(data)
    const tempLink = document.createElement('a')
    tempLink.href = csvURL
    tempLink.setAttribute('download', filename)
    tempLink.click()
  }, [])

  const ReplaceVars = useCallback(
    (cmd: string, allowTerminalWrap:boolean) => {
      if (
        ahost === undefined ||
        aport === undefined ||
        httpFile === undefined
      ) {
        return ''
      }

      let tmp = cmd

      tmp = tmp.replaceAll('__AHOST__', ahost)
      tmp = tmp.replaceAll('__APORT__', aport.toString())

      const httpPath = httpFile.split('/')
      const httpFileName = httpPath.pop()
      const httpRootPath = httpPath.join('/')

      tmp = tmp.replaceAll('/__PATH__', httpRootPath)
      tmp = tmp.replaceAll(
        '__FILE__',
        httpFileName !== undefined ? httpFileName : ''
      )


      if(allowTerminalWrap === true && terminalWrap !== undefined && terminalWrap !== ''){
        return terminalWrap.replaceAll('__CMD__', tmp)
      }

      return tmp
    },
    [ahost, aport, httpFile, terminalWrap]
  )

  //   const FileOptions = useMemo(()=> {
  //     Files
  //   }, [])

  const CommandOptions = useMemo(() => {
    if (search === undefined) {
      return
    }

    // search = search.toLowerCase()
    const search_terms = search.toLowerCase().split(' ')
    const found: Array<CommandsProps> = []

    for (const term of search_terms) {
      // find all of the commands which match the omnisearch term(s))
      found.push(
        ...(Commands as Array<CommandsProps>).filter((c) => {
          return (
            c.keywords.filter((k) => k.toLowerCase().indexOf(term)).length > 0
          )
        })
      )
    }

    // filter out only the unique ids from the matches
    const unique_found = found.filter(
      (value, index, self) => self.findIndex((v) => v.id === value.id) === index
    )

    // create GUI options for the user to start drilling into the command to build
    return unique_found.map((f) => {
      return f.cmds.map((c) => {
        if (c.cmd.indexOf('__PATH__') > -1 && c.cmd.indexOf('__FILE__') > -1) {
          setTimeout(() => {
            setFileSearchEnabled(true)
          }, 1)
        }

        return (
          <ListItem key={`${f.id}-${c.win}-${c.label.replace(' ', '-')}`}>
            <Button
              variant="outlined"
              onClick={() => {
                setCommand_windows((prev) => {
                  let tmp = [] as Array<CMDProps>

                  if (prev === undefined) {
                    tmp = new Array<CMDProps>(c.win)
                    tmp.push(c)
                    return tmp
                  }

                  if (prev !== undefined) {
                    tmp = [...prev]

                    if (prev.length > c.win) {
                      tmp[c.win] = c
                    } else {
                      tmp.push(c)
                    }

                    return tmp
                  }
                })
              }}
            >
              {c.label}
            </Button>
          </ListItem>
        )
      })
    })
  }, [search])

  const Windows = useMemo(() => {
    if (command_windows === undefined) {
      return <></>
    }

    return command_windows.map((cwin) => {
      const DownloadFiles = () => {
        if (cwin?.code?.length === undefined || cwin.code.length < 1) {
          return <></>
        }

        return cwin.code.map((code) => {
          return (
            <ListItem key={code.filename}>
              <CopyItem val={atob(code.data)}>
                <IconButton
                  onClick={() => {
                    download_file(code.filename, code.data)
                  }}
                >
                  {code.filename}&nbsp;
                  <CloudDownloadIcon />
                </IconButton>
              </CopyItem>
            </ListItem>
          )
        })
      }

      return (
        <Box key={cwin.win} sx={{ borderTop: '1px solid #cecece' }}>
          <Typography>
            Window {cwin.win} Platform:{cwin.platform}
          </Typography>
          <CopyItem val={ReplaceVars(cwin.cmd, cwin.allowTerminalWrap)}>
            <Typography
              variant="caption"
              sx={{
                fontFamily: 'monospace',
                background: '#000',
                padding: '10px',
                borderRadius: '5px',
                margin: '10px',
              }}
            >
              {ReplaceVars(cwin.cmd, cwin.allowTerminalWrap)}
            </Typography>
          </CopyItem>

          <List>
            <DownloadFiles />
          </List>
        </Box>
      )
    })
  }, [command_windows, ahost, aport, httpFile, terminalWrap])

  return (
    <>
      <Grid container>
        <Grid item xs={3}>
          <List>{CommandOptions}</List>
        </Grid>
        <Grid item xs={9}>
          <Box id="windows-box">{Windows}</Box>
        </Grid>
        <Grid item xs={12}>
          <Typography>Tools</Typography>
          {fileSearchEnabled && (
            <Autocomplete
              disablePortal
              id="omni-filesearch-box"
              options={Files as Array<string>}
              sx={{ width: 300 }}
              renderInput={(params) => (
                <TextField {...params} label="File Search..." />
              )}
              onChange={(
                event: React.SyntheticEvent,
                newValue: string | null
              ) => {
                setHTTPFile(newValue)
              }}
            />
          )}

          <Autocomplete
            disablePortal
            id="omni-terminalsearch-box"
            options={CommandWrap as Array<TerminalProps>}
            getOptionLabel={(option) => option.term}
            sx={{ width: 300 }}
            renderInput={(params) => (
              <TextField {...params} label="Process Terminal Wrap..." />
            )}
            onChange={(
              event: React.SyntheticEvent,
              newValue: TerminalProps | null
            ) => {
                if(newValue === undefined || newValue === null){
                    return
                }

                setTerminalWrap(newValue.cmd)
            }}
            isOptionEqualToValue={function (
                option: TerminalProps,
                value: TerminalProps
              ) {
                if (option.cmd === value.cmd && option.term === value.term) {
                  return true
                }
    
                return false
              }}
          />
        </Grid>
      </Grid>
    </>
  )
}

export default CommandConfigurator
