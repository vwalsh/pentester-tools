import Commands from '../../assets/commands.json'

import { useCallback, useMemo } from 'react'
import {
  Autocomplete,
  Box,
  Button,
  Grid,
  IconButton,
  List,
  ListItem,
  TextField,
  Typography,
} from '@mui/material'
import CloudDownloadIcon from '@mui/icons-material/CloudDownload'
import CopyItem from '../CopyItem'
import React from 'react'
import AlertDialog from '../AlertDialog'
import ConfigInput, { InputProps } from '../ConfigInput/ConfigInput'
import {
  ahost,
  aport,
  fileSearchEnabled,
  httpFile,
  replacements,
  search,
  setReplacements,
  setTerminalWrap,
  terminalWraps,
} from '../../signals/signals'
import { Signal, useSignal, useSignalEffect } from '@preact/signals-react'

interface CMDProps {
  win: number
  label: string
  platform: 'windows' | 'linux' | 'linux|windows'
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>
  cmd: string
  config?: Array<{
    help: string
    replace: string
    defaultValue: number | string
    props: InputProps
  }>
  allowTerminalWrap: boolean
  code?: Array<{
    filename: string
    data: string
  }>
}

interface CommandsProps {
  id: string
  keywords: Array<string>
  cmds: Array<CMDProps>
}

interface TerminalProps {
  term: string
  cmd: string
}

interface CommandOptionsProps {
  command_windows: Signal<CMDProps[]>
}

function download_file(filename: string, b64data: string) {
  const data = new Blob([atob(b64data)], { type: 'text' })
  const csvURL = window.URL.createObjectURL(data)
  const tempLink = document.createElement('a')
  tempLink.href = csvURL
  tempLink.setAttribute('download', filename)
  tempLink.click()
}

const CommandOptions = ({ command_windows }: CommandOptionsProps) => {
  const unique_found = useSignal<undefined | Array<CommandsProps>>(undefined)

  useSignalEffect(() => {
    const found = [] as Array<CommandsProps>
    for (const term of search.value.toLowerCase().split(' ')) {
      // find all of the commands which match the omnisearch term(s))
      found.push(
        ...(Commands as Array<CommandsProps>).filter((c) => {
          return (
            c.keywords.filter((k) => k.toLowerCase().indexOf(term)).length > 0
          )
        })
      )
    }

    // filter out only the unique ids from the matches
    unique_found.value = found.filter(
      (value, index, self) => self.findIndex((v) => v.id === value.id) === index
    )
  })

  if (search.value === undefined || unique_found.value === undefined) {
    return <></>
  }

  // create GUI options for the user to start drilling into the command to build
  return unique_found?.value.map((f) => {
    return f.cmds.map((c) => {
      if (c.cmd.indexOf('__PATH__') > -1 && c.cmd.indexOf('__FILE__') > -1) {
        setTimeout(() => {
          // NOTE: this fixes a render bug in react when rendering the Home comp you can't also set a state!
          fileSearchEnabled.value = true
        }, 1)
      }

      return (
        <ListItem key={`${f.id}-${c.win}-${c.label.replace(' ', '-')}`}>
          <Button
            variant="outlined"
            onClick={() => {
              let tmp = [] as Array<CMDProps>
              if (
                command_windows.value === undefined ||
                command_windows.value.length < 1
              ) {
                tmp = new Array<CMDProps>(c.win)
                tmp.push(c)
                //   return tmp
              }
              if (
                command_windows.value !== undefined &&
                command_windows.value.length > 0
              ) {
                tmp = [...command_windows.value]
                if (command_windows.value.length > c.win) {
                  tmp[c.win] = c
                } else {
                  tmp.push(c)
                }
              }
              command_windows.value = tmp
            }}
          >
            {c.label}
          </Button>
        </ListItem>
      )
    })
  })
}

function CommandConfigurator() {
  const command_windows = useSignal<Array<CMDProps>>([])

  const ReplaceVars = useCallback(
    (winN: number, cmd: string, allowTerminalWrap: boolean) => {
      if (
        ahost.value === undefined ||
        aport.value === undefined ||
        httpFile.value === undefined
      ) {
        return ''
      }

      let tmp = cmd

      tmp = tmp.replaceAll('__AHOST__', ahost.value)
      tmp = tmp.replaceAll('__APORT__', aport.value.toString())

      const httpPath = httpFile.value.split('/')
      const httpFileName = httpPath.pop()
      const httpRootPath = httpPath.join('/')

      tmp = tmp.replaceAll('/__PATH__', httpRootPath)
      tmp = tmp.replaceAll(
        '__FILE__',
        httpFileName !== undefined ? httpFileName : ''
      )

      //   wrap the running command with the process spawn of choice
      if (
        allowTerminalWrap === true &&
        terminalWraps.value !== undefined &&
        terminalWraps.value[`win-${winN}`] !== undefined
      ) {
        tmp = terminalWraps.value[`win-${winN}`]
          .toString()
          .replaceAll('__CMD__', tmp)
      }

      //   replace all of the config set properties
      if (replacements.value !== undefined) {
        Object.keys(replacements.value).forEach(function (key) {
          tmp = tmp.replaceAll(key, replacements.value[key].toString())
        })
      }
      return tmp
    },
    []
  )

  //   return array with data indexed to each window id
  // [cwin.win] => JSX.Element[]
  const ConfigComps = useMemo((): Array<JSX.Element[]> => {
    if (
      command_windows.value === undefined ||
      command_windows.value.length < 1
    ) {
      return [
        [<React.Fragment key={`command_windows_undefined`}></React.Fragment>],
      ]
    }

    const tmp = new Array(command_windows.value.length) as Array<JSX.Element[]>

    for (let i = 0; i < command_windows.value.length; i++) {
      const cwin = command_windows.value[i]
      if (
        cwin?.config === undefined ||
        cwin?.config?.length === undefined ||
        cwin.config.length < 1
      ) {
        tmp[cwin?.win === undefined ? i : cwin.win] = [
          <React.Fragment
            key={`command_windows_${i}-${cwin?.win}`}
          ></React.Fragment>,
        ]
        continue
      }

      tmp[cwin.win] = cwin.config.map((cfg) => {
        if (replacements.value[cfg.replace] === undefined)
          setReplacements({ name: cfg.replace, value: cfg.defaultValue })

        return (
          <ListItem key={btoa(JSON.stringify(cfg))}>
            <AlertDialog title={cfg.props.label}>
              <Typography>{cfg.help}</Typography>
            </AlertDialog>

            <ConfigInput
              defaultValue={
                replacements.value[cfg.replace] === undefined
                  ? cfg.defaultValue
                  : replacements.value[cfg.replace]
              }
              replace={cfg.replace}
              props={cfg.props}
            />
          </ListItem>
        )
      })
    }

    return tmp
  }, [command_windows.value])

  const Windows = () => {
    if (
      command_windows.value === undefined ||
      command_windows.value.length < 1
    ) {
      return <></>
    }

    const CommandWrap: Array<TerminalProps> = [
      { term: 'None', cmd: `__CMD__` },
      { term: 'Powershell -c', cmd: `powershell -c '__CMD__'` },
      {
        term: 'PS.exe -c',
        cmd: `C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -c '__CMD__'`,
      },
      { term: 'CMD in PS Prompt', cmd: `cmd /r '__CMD__'` },
      { term: '/bin/sh -c', cmd: `/bin/sh -c '__CMD__'` },
      { term: '/bin/bash -c', cmd: `/bin/bash -c '__CMD__'` },
    ]

    return command_windows.value.map((cwin) => {
      // TODO: using the ConfigComps pattern turn this DownloadFiles into a useMemo above
      const DownloadFiles = () => {
        if (cwin?.code?.length === undefined || cwin.code.length < 1) {
          return <></>
        }

        return cwin.code.map((code) => {
          return (
            <ListItem key={code.filename}>
              <CopyItem val={atob(code.data)}>
                <IconButton
                  onClick={() => {
                    download_file(code.filename, code.data)
                  }}
                >
                  {code.filename}&nbsp;
                  <CloudDownloadIcon />
                </IconButton>
              </CopyItem>
            </ListItem>
          )
        })
      }

      return (
        <Box key={`window-${cwin.win}`} sx={{ borderTop: '1px solid #cecece' }}>
          <Typography>
            Window {cwin.win} Platform:{cwin.platform}
          </Typography>
          <CopyItem
            val={ReplaceVars(cwin.win, cwin.cmd, cwin.allowTerminalWrap)}
          >
            <Typography
              variant="caption"
              sx={{
                fontFamily: 'monospace',
                background: '#000',
                padding: '10px',
                borderRadius: '5px',
                margin: '10px',
              }}
            >
              {ReplaceVars(cwin.win, cwin.cmd, cwin.allowTerminalWrap)}
            </Typography>
          </CopyItem>

          <List>
            <DownloadFiles />
          </List>

          <List>
            {ConfigComps[cwin.win]}

            <ListItem key={`omni-terminalsearch-box-${cwin.win}`}>
              <Autocomplete
                disablePortal
                id={`omni-terminalsearch-box-${cwin.win}`}
                options={CommandWrap as Array<TerminalProps>}
                getOptionLabel={(option) => option.term}
                sx={{ width: 300 }}
                value={
                  CommandWrap.filter(
                    (cmdWrap) =>
                      cmdWrap.cmd ===
                      (terminalWraps.value[`win-${cwin.win}`] !== undefined
                        ? terminalWraps.value[`win-${cwin.win}`]
                        : '__CMD__')
                  )[0]
                }
                renderInput={(params) => (
                  <TextField {...params} label="Process Terminal Wrap..." />
                )}
                onChange={(
                  event: React.SyntheticEvent,
                  newValue: TerminalProps | null
                ) => {
                  if (newValue === undefined || newValue === null) {
                    return
                  }

                  setTerminalWrap({
                    name: `win-${cwin.win}`,
                    value: newValue.cmd,
                  })
                }}
                isOptionEqualToValue={function (
                  option: TerminalProps,
                  value: TerminalProps
                ) {
                  if (option.cmd === value.cmd && option.term === value.term) {
                    return true
                  }

                  return false
                }}
              />
            </ListItem>
          </List>
        </Box>
      )
    })
  }

  return (
    <>
      <Grid container>
        <Grid item xs={3}>
          <List>
            <CommandOptions command_windows={command_windows} />
          </List>
        </Grid>
        <Grid item xs={9}>
          <Box id="windows-box">
            <Windows />
          </Box>
        </Grid>
      </Grid>
    </>
  )
}

export default CommandConfigurator
