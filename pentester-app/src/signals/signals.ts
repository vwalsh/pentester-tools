import { effect, signal } from '@preact/signals-react'
import { CommandWindowsProps } from '../pages/Home/components/ConfigInput/ConfigInput'

export interface NameValueDict {
  [id: string]: string | number
}

export interface NameValueStringDict {
  [id: string]: string
}

export interface BooleanDict {
  [id: string]: boolean
}

export interface ReplacementsProps {
  name: string
  value: string | number
}

export interface LootProps {
  name: string
  value: string
}

export default function createCommandConfiguratorState() {
  // ============================================================================
  // stores the command windows shown after a search is done and a command has been clicked on.
  // temporary storage, not persistent
  const command_windows = signal<Array<CommandWindowsProps | undefined>>([])
  const setCommand_windows = (
    update: Array<CommandWindowsProps | undefined>
  ) => {
    // console.log('setCommand_windows', update)
    command_windows.value = update
  }

  // ============================================================================
  // History of copied commands-to-run
  const commandHistory = signal(getCommandHistory())

  function getCommandHistory(): Array<string> {
    const value = localStorage.getItem('commandHistory')
    if (value == null) return []
    return JSON.parse(value)
  }

  function addCommandHistory(cmd: string) {
    // add to the command history
    commandHistory.value = [...commandHistory.value, cmd]
  }

  effect(() => {
    localStorage.setItem('commandHistory', JSON.stringify(commandHistory.value))
  })

  // ============================================================================
  // name,value pair replacements for the command strings
  const replacements = signal(getReplacements())

  function getReplacements(): NameValueDict {
    const value = localStorage.getItem('replacements')
    if (value == null) return {}
    return JSON.parse(value)
  }

  function setReplacements({ name, value }: ReplacementsProps) {
    //   make a copy of the original values and extend them as needed
    // uses object properties to avoid name collisions
    const tmp = { ...replacements.value }
    tmp[name] = value
    replacements.value = tmp
  }

  function getReplacementValue(name: string): string | number | undefined {
    return replacements.value?.[name]
  }

  effect(() => {
    localStorage.setItem('replacements', JSON.stringify(replacements.value))
  })

  // ============================================================================
  // per command the user can decide which wrapping they want around running the command, none as default
  const terminalWraps = signal(getTerminalWrap())

  function getTerminalWrap(): NameValueDict {
    const value = localStorage.getItem('terminalWraps')
    if (value == null) return {}
    return JSON.parse(value)
  }

  function setTerminalWrap({ name, value }: ReplacementsProps) {
    //   make a copy of the original values and extend them as needed
    // uses object properties to avoid name collisions
    const tmp = { ...terminalWraps.value }
    tmp[name] = value
    terminalWraps.value = tmp
  }

  effect(() => {
    localStorage.setItem('terminalWraps', JSON.stringify(terminalWraps.value))
  })

  // ============================================================================
  // per command the user can decide which wrapping they want around running the command, none as default
  const proxychainPrepends = signal(getProxychainPrepends())

  function getProxychainPrepends(): NameValueDict {
    const value = localStorage.getItem('proxychainPrepends')
    if (value == null) return {}
    return JSON.parse(value)
  }

  function setProxychainPrepends({ name, value }: ReplacementsProps) {
    //   make a copy of the original values and extend them as needed
    // uses object properties to avoid name collisions
    const tmp = { ...proxychainPrepends.value }
    tmp[name] = value
    proxychainPrepends.value = tmp
  }

  effect(() => {
    localStorage.setItem(
      'proxychainPrepends',
      JSON.stringify(proxychainPrepends.value)
    )
  })

  // ============================================================================
  // Loot storage - persistent
  // stores all of the loot the user has entered
  const loot = signal(getLoot())

  function getLoot(): NameValueStringDict {
    const value = localStorage.getItem('loot')
    if (value == null) return {}
    return JSON.parse(value)
  }

  function setLoot({ name, value }: LootProps) {
    //   make a copy of the original values and extend them as needed
    // uses object properties to avoid name collisions
    const tmp = { ...loot.value }
    tmp[name] = value
    loot.value = tmp
  }

  effect(() => {
    localStorage.setItem('loot', JSON.stringify(loot.value))
  })

  // ============================================================================
  const httpFile = signal(getHttpFile())

  function getHttpFile(): string {
    const value = localStorage.getItem('httpFile')
    if (value == null) return ''
    return value
  }

  effect(() => {
    localStorage.setItem('httpFile', httpFile.value)
  })

  // ============================================================================
  // the search value(s) entered in the Command Search box on the Tools page
  const commandSearch = signal<Array<string>>([])

  // ============================================================================
  const ahost = signal(getAhost())

  function getAhost(): string {
    const value = localStorage.getItem('ahost')
    if (value == null) return ''
    return value
  }

  effect(() => {
    localStorage.setItem('ahost', ahost.value)
  })

  // ============================================================================
  const aport = signal(getAport())

  function getAport(): number {
    const value = localStorage.getItem('aport')
    if (value == null) return 8000
    return parseInt(value)
  }

  effect(() => {
    localStorage.setItem('aport', aport.value.toString())
  })

  // ============================================================================
  const vhost = signal(getVhost())

  function getVhost(): string {
    const value = localStorage.getItem('vhost')
    if (value == null) return ''
    return value
  }

  effect(() => {
    localStorage.setItem('vhost', vhost.value)
  })

  // ============================================================================
  const vport = signal(getVport())

  function getVport(): number {
    const value = localStorage.getItem('vport')
    if (value == null) return 8000
    return parseInt(value)
  }

  effect(() => {
    localStorage.setItem('vport', vport.value.toString())
  })

  // ============================================================================
  // holds a non-local-storage state of the replaced values for the commands-to-run
  const replacedValues = signal<BooleanDict>({})

  function updateReplacedValues(commandIdentifier: string, obj: BooleanDict) {
    let tmp = { ...replacedValues.value }

    for (const val in tmp) {
      // delete any of the matching properties to cleanup state before the updated object is added in.
      if (val.indexOf(commandIdentifier) === 0) {
        delete tmp[val]
      }
    }

    tmp = { ...tmp, ...obj }

    replacedValues.value = tmp
  }

  function findReplacedValue(id: string): boolean {
    // console.log('findReplacedValue', id, replacedValues.value[id] === true)
    return replacedValues.value[id] === true
  }

  // ============================================================================
  // holds the status of the last backup sha256 hash. if the current localstorage doesn't hash to the same value,
  // then they are out of date. when calculating the hash of all the localstorage object, this hash value cannot be included
  //  or it would be a recursive hash!
  const backupJsonHash = signal(getBackupJsonHash())

  function getBackupJsonHash(): string {
    const value = localStorage.getItem('backupJsonHash')
    if (value == null) return ''
    return value
  }

  effect(() => {
    localStorage.setItem('backupJsonHash', backupJsonHash.value)
  })

  // ============================================================================
  // DEBUGGING:
  // ============================================================================
  // effect(() => {
  //   console.log('replacements', replacements.value)
  // })

  // effect(() => {
  //   console.log('commandSearch', commandSearch.value)
  // })
  // ============================================================================

  return {
    ahost,
    aport,
    httpFile,
    replacements,
    commandSearch,
    setReplacements,
    getReplacementValue,
    setTerminalWrap,
    terminalWraps,
    proxychainPrepends,
    setProxychainPrepends,
    vhost,
    vport,
    command_windows,
    setCommand_windows,
    loot,
    setLoot,
    commandHistory,
    addCommandHistory,
    replacedValues,
    updateReplacedValues,
    findReplacedValue,
    backupJsonHash,
  }
}
