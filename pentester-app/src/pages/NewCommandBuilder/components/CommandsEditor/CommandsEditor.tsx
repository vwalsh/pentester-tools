import React, { useEffect } from 'react'
import { useSignal, useComputed, Signal } from '@preact/signals-react'
import AlertDialog from '../../../../components/AlertDialog'
import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  Grid,
  IconButton,
  InputAdornment,
  List,
  ListItem,
  TextField,
  Typography,
} from '@mui/material'
import {
  CMDConfigProps,
  CMDProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import NumberInput from '../../../../components/NumberInput'
import { globalReplacements } from '../../dataStructures'
import ConfigsEditor from '../ConfigsEditor'
import TravelExploreIcon from '@mui/icons-material/TravelExplore'
import TuneIcon from '@mui/icons-material/Tune'
import DeleteIcon from '@mui/icons-material/Delete'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import GlobalReplacementsDialog from '../../../../components/GlobalReplacementsDialog'

interface Props {
  commandWindows: Signal<Array<CMDProps>>
  editCommandWindow: Signal<undefined | CMDProps>
}

const PlatformOptions = ['windows', 'linux', 'linux|windows']
const TerminalOptions: ('ps' | 'cmd' | 'sh' | 'bash')[] = [
  'ps',
  'cmd',
  'sh',
  'bash',
]

const CommandsEditor = React.memo(
  ({ commandWindows, editCommandWindow }: Props) => {
    const winN = useSignal<number>(0)
    const commandToRun = useSignal<string>('')

    const label = useSignal({ error: false, value: '' })
    const platform = useSignal<'windows' | 'linux' | 'linux|windows'>('linux')
    const terminals = useSignal<('ps' | 'cmd' | 'sh' | 'bash')[]>([])
    const allowTerminalWrap = useSignal<boolean>(true)

    const configs = useSignal<Array<CMDConfigProps>>([])
    const editConfig = useSignal<undefined | CMDConfigProps>(undefined)

    const resetStateToDefaults = () => {
      // clear the values for the next command (back to defaults):
      winN.value = 0
      label.value = { value: '', error: false }
      platform.value = 'linux'
      terminals.value = []
      allowTerminalWrap.value = true
      commandToRun.value = ''

      // config property can be undefined
      configs.value = []

      // get out of edit mode
      editCommandWindow.value = undefined
    }

    const handleOnAccept = () => {
      commandWindows.value = [
        ...commandWindows.value,
        {
          win: winN.value,
          label: label.value.value,
          platform: platform.value,
          terminal: terminals.value,
          allowTerminalWrap: allowTerminalWrap.value,
          cmd: commandToRun.value,

          // config property can be undefined
          ...(configs.value.length > 0 && { config: configs.value }),
        },
      ]

      resetStateToDefaults()
    }

    const handleOnEdit = () => {
      const updated = commandWindows.value.map((cmd) => {
        if (cmd === editCommandWindow.value) {
          return {
            win: winN.value,
            label: label.value.value,
            platform: platform.value,
            terminal: terminals.value,
            allowTerminalWrap: allowTerminalWrap.value,
            cmd: commandToRun.value,

            // config property can be undefined
            ...(configs.value.length > 0 && { config: configs.value }),
          } as CMDProps
        }

        return cmd
      })

      commandWindows.value = updated

      resetStateToDefaults()
    }

    const compiledCommand = useComputed(() => {
      // this builds the command by replacing the __VALUE__ with their example inputs or their defaultValues
      let tmp = commandToRun.value

      globalReplacements.forEach((rep) => {
        tmp = tmp.replaceAll(rep.replace, rep.example)
      })
      return tmp
    })

    useEffect(() => {
      switch (platform.value) {
        case 'linux':
          terminals.value = ['sh', 'bash']
          break
        case 'windows':
          terminals.value = ['ps', 'cmd']
          break
        case 'linux|windows':
          terminals.value = ['ps', 'cmd', 'sh', 'bash']
          break
      }
    }, [platform.value, terminals])

    useEffect(() => {
      if (editCommandWindow.value === undefined) {
        return
      }

      // clear the values for the next command (back to defaults):
      winN.value = editCommandWindow.value.win
      label.value = { value: editCommandWindow.value.label, error: false }
      platform.value = editCommandWindow.value.platform
      terminals.value = editCommandWindow.value.terminal
      allowTerminalWrap.value = editCommandWindow.value.allowTerminalWrap
      commandToRun.value = editCommandWindow.value.cmd

      // config property can be undefined
      configs.value =
        editCommandWindow.value.config === undefined
          ? []
          : editCommandWindow.value.config
    }, [
      allowTerminalWrap,
      commandToRun,
      configs,
      editCommandWindow.value,
      label,
      platform,
      terminals,
      winN,
    ])

    const CommandConfigs = React.memo(() => {
      if (configs.value === undefined || configs.value.length < 1) {
        return
      }

      return configs.value.map((cfg) => {
        return (
          <ListItem
            key={`cmd-cfg-${cfg.props.label}`}
            sx={{
              border: '1px solid #cecece',
              ...(editConfig.value !== undefined &&
                editConfig.value === cfg && { background: '#4a2a00' }),
            }}
          >
            <Typography>
              Command:{label.value.value} {cfg.props.label} | Replace='
              {cfg.replace}' with Default '{cfg.defaultValue.toString()}' as{' '}
              {cfg.props.type}
            </Typography>
            <IconButton
              onClick={() => {
                editConfig.value = cfg
              }}
            >
              <TuneIcon />
            </IconButton>
            <IconButton
              onClick={() => {
                configs.value = configs.value.filter((f) => {
                  return cfg.replace !== f.replace
                })
              }}
            >
              <DeleteIcon />
            </IconButton>
          </ListItem>
        )
      })
    })

    return (
      <Box
        sx={{
          width: '99%',
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          height: '100%',
          margin: '25px',
          padding: '15px',
          overflow: 'hidden',
        }}
      >
        {editCommandWindow.value === undefined && (
          <Button color="success" variant="contained" onClick={handleOnAccept}>
            Accept NEW Command
          </Button>
        )}

        {editCommandWindow.value !== undefined && (
          <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
            <Button color="warning" variant="contained" onClick={handleOnEdit}>
              Accept Edits to Command {label.value.value}
            </Button>

            <ConfirmDialog
              buttonText="Discard Edits"
              title="Discard any edits to this Command?"
              desc="Press Confirm below to stop editing this command, any config input changes and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
              onConfirm={() => {
                resetStateToDefaults()
              }}
            />
          </Box>
        )}

        <TextField
          label="Command Short Name"
          value={label.value.value}
          fullWidth
          error={label.value.error}
          helperText={
            label.value.error === true
              ? 'Must be a unique name within this set of commands'
              : ''
          }
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Help: Command Short Name`}>
                  <Typography>
                    The command short name is displayed when searching for
                    commands on the left side of the Configurator under the
                    search box. This value should be relatively short and still
                    convey which tool is being used in this command.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            const tmp = event.target.value

            const f = commandWindows.value.filter((cmd) => {
              return cmd.label.toLowerCase() === tmp.toLowerCase()
            })

            if (f.length > 0) {
              // must be unique
              label.value = { error: true, value: tmp }
            } else {
              label.value = { error: false, value: tmp }
            }
          }}
        />

        <NumberInput
          props={{
            fullWidth: true,
            label: 'Command Window Number',
            InputProps: {
              inputProps: { min: 1, max: 15 },
              startAdornment: (
                <InputAdornment position="start">
                  <AlertDialog title="Command Window Number Help">
                    <Typography>
                      The Command Window Number is a zero-indexed value that
                      indicates which window this command is expected to run in.
                      Typically a pentester has a terminal window setup with
                      several sub-windows or splits. To keep the commands
                      organized in a reasonable fashion, the Command Window
                      Number is used to determine which sub-window the command
                      should be run within. This allows creating many options
                      for the type of command the pentester wants to run, while
                      grouping like-commands together and eliminating confusion
                      in the UI.
                      <br />
                      <br />
                      TIP: use 0 for all of the commands until a command needs
                      to be run in parallel to accomplish a goal and then
                      increment the Command Window Number for each parallel task
                      required. Eg, use 0 for all of the commands which do the
                      same task, and then increment to 1 for setting up a
                      parallel task like running a server, which the Command
                      Window 0 task will potentially interact with during the
                      pentest.
                      <br />
                      <br />
                      Min 0, Max 15
                    </Typography>
                  </AlertDialog>
                </InputAdornment>
              ),
            },
            value: winN.value,
          }}
          // onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          //   winN.value = parseInt(event.target.value)
          // }}
          numberChangeEvent={(n) => {
            winN.value = n
          }}
        />

        <TextField
          id="command-to-build-textinput"
          label="Command to build"
          value={commandToRun.value}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            commandToRun.value = event.target.value
          }}
          multiline
          fullWidth
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Building a Command`}>
                  <Typography>
                    To build a command enter an example command and then start
                    to replace static values with __VALUE__ type strings. These
                    can either come from the Global Replacements (eg
                    __ATTACKER_HOST__) or a custom value defined by adding a
                    Config Tool. The value is considered a global replacement
                    even if it's within a config tool. This helps tools share
                    common values between them. If it's better to have it
                    specific to this tool a good convention is to prepend the
                    tool name to the value (eg __XFREERDP_USERNAME__). Be sure
                    to use the copy button next to the global replacements
                    values to avoid mistakes.
                    <br />
                    <br />
                    NOTE: Click on the <TravelExploreIcon /> to copy from the
                    Global Replacements list.
                  </Typography>
                </AlertDialog>
                <GlobalReplacementsDialog />
              </InputAdornment>
            ),
          }}
        />

        <TextField
          id="compiled-command"
          multiline
          fullWidth
          value={compiledCommand.value}
          label="Compiled Command Output"
          disabled
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Compiled Command Example`}>
                  <Typography>
                    This textfield will show what the command could look like
                    with example data plugged into the __VALUE__ replacement
                    strings.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />

        <Autocomplete
          disablePortal
          options={PlatformOptions}
          sx={{ width: 300 }}
          renderInput={(params) => (
            <TextField {...params} label={'Platform, aka OS'} />
          )}
          value={platform.value}
          onChange={(_event: React.SyntheticEvent, newValue: string | null) => {
            if (
              newValue === null ||
              (newValue !== 'linux' &&
                newValue !== 'linux|windows' &&
                newValue !== 'windows')
            ) {
              // default if somehow they select nothing or an unavailable option
              platform.value = 'linux'
              return
            }
            platform.value = newValue
          }}
        />

        <Autocomplete
          disablePortal
          multiple
          options={TerminalOptions}
          sx={{ width: 300 }}
          renderInput={(params) => (
            <TextField {...params} label={'Terminal Options'} />
          )}
          value={terminals.value}
          onChange={(
            _event: React.SyntheticEvent,
            newValue: string[] | null
          ) => {
            if (newValue === null) {
              // default if somehow they select nothing
              terminals.value = []
              return
            }

            terminals.value = newValue as ('ps' | 'cmd' | 'sh' | 'bash')[]
          }}
        />

        <FormGroup>
          <FormControlLabel
            sx={{ userSelect: 'none' }}
            control={
              <Checkbox
                inputProps={{
                  'aria-label':
                    'Allow Terminal Wrap Options eg PS Base64 encoded command',
                }}
                checked={allowTerminalWrap.value}
                onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                  allowTerminalWrap.value = event.target.checked
                }}
              />
            }
            label={'Allow Terminal Wrap Options eg PS Base64 encoded command'}
          />
        </FormGroup>

        <Grid container>
          <Grid item xs={3}>
            <Typography variant="h5">Config Inputs:</Typography>
            <List sx={{ margin: '10px' }}>
              <CommandConfigs />
            </List>
          </Grid>
          <Grid item xs={9}>
            <ConfigsEditor configs={configs} editConfig={editConfig} />
          </Grid>
        </Grid>
      </Box>
    )
  }
)

export default CommandsEditor
