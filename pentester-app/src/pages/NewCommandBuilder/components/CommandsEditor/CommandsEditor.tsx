import React, { useEffect } from 'react'
import { useSignal, useComputed, Signal } from '@preact/signals-react'
import AlertDialog from '../../../../components/AlertDialog'
import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  Grid,
  InputAdornment,
  ListItem,
  TextField,
  Typography,
} from '@mui/material'
import {
  CMDConfigProps,
  CMDProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import NumberInput from '../../../../components/NumberInput'
import { globalReplacements } from '../../dataStructures'
import ConfigsEditor from '../ConfigsEditor'
import TravelExploreIcon from '@mui/icons-material/TravelExplore'
import TuneIcon from '@mui/icons-material/Tune'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import GlobalReplacementsDialog from '../../../../components/GlobalReplacementsDialog'
import DownloadsEditor from '../DownloadsEditor'
import { DownloadsProp } from '../DownloadsEditor/DownloadsEditor'
import CodeTypography from '../../../../components/CodeTypography'

interface Props {
  editorReset: Signal<number>
  commandWindows: Signal<Array<CMDProps>>
  editCommandWindow: Signal<undefined | CMDProps>
}

const PlatformOptions = ['windows', 'linux', 'linux|windows']
const TerminalOptions: ('ps' | 'cmd' | 'sh' | 'bash')[] = [
  'ps',
  'cmd',
  'sh',
  'bash',
]

const CommandsEditor = React.memo(
  ({ commandWindows, editCommandWindow, editorReset }: Props) => {
    const winN = useSignal<number>(0)
    const commandToRun = useSignal<string>('')

    const label = useSignal({ error: false, value: '' })
    const platform = useSignal<'windows' | 'linux' | 'linux|windows'>('linux')
    const terminals = useSignal<('ps' | 'cmd' | 'sh' | 'bash')[]>([
      'sh',
      'bash',
    ])
    const allowTerminalWrap = useSignal<boolean>(true)
    const allowProxychains = useSignal<boolean>(true)
    const configs = useSignal<Array<CMDConfigProps>>([])
    const editConfig = useSignal<undefined | CMDConfigProps>(undefined)
    const codeDownloadOptions = useSignal<Array<DownloadsProp>>([])

    const resetStateToDefaults = () => {
      // clear the values for the next command (back to defaults):
      winN.value = 0
      label.value = { value: '', error: false }
      platform.value = 'linux'
      terminals.value = ['sh', 'bash']
      allowTerminalWrap.value = true
      allowProxychains.value = true
      commandToRun.value = ''
      codeDownloadOptions.value = []

      configs.value = []

      // get out of edit mode
      editCommandWindow.value = undefined
    }

    const handleOnAccept = () => {
      // this runs when the user has finished creating a new command and hit the accept button
      commandWindows.value = [
        ...commandWindows.value,
        {
          win: winN.value,
          label: label.value.value,
          platform: platform.value,
          terminal: terminals.value,
          allowTerminalWrap: allowTerminalWrap.value,
          allowProxychains: allowProxychains.value,
          cmd: commandToRun.value,
          code: codeDownloadOptions.value,

          // config property can be undefined
          ...(configs.value.length > 0 && { config: configs.value }),
        },
      ]

      resetStateToDefaults()
    }

    const handleOnEdit = () => {
      // this runs when the user has finished editing and clicked the edit save button
      const updated = commandWindows.value.map((cmd) => {
        if (cmd === editCommandWindow.value) {
          return {
            win: winN.value,
            label: label.value.value,
            platform: platform.value,
            terminal: terminals.value,
            allowTerminalWrap: allowTerminalWrap.value,
            allowProxychains: allowProxychains.value,
            cmd: commandToRun.value,
            code: codeDownloadOptions.value,

            // config property can be undefined
            ...(configs.value.length > 0 && { config: configs.value }),
          } as CMDProps
        }

        return cmd
      })

      commandWindows.value = updated

      resetStateToDefaults()
    }

    const compiledCommand = useComputed(() => {
      // this builds the command by replacing the __VALUE__ with their example inputs or their defaultValues
      let tmp = commandToRun.value

      globalReplacements.forEach((rep) => {
        tmp = tmp.replaceAll(rep.replace, rep.example)
      })
      return tmp
    })

    useEffect(() => {
      switch (platform.value) {
        case 'linux':
          terminals.value = ['sh', 'bash']
          break
        case 'windows':
          terminals.value = ['ps', 'cmd']
          break
        case 'linux|windows':
          terminals.value = ['ps', 'cmd', 'sh', 'bash']
          break
      }
    }, [platform.value, terminals])

    useEffect(() => {
      if (editCommandWindow.value === undefined) {
        return
      }

      // clear the values for the next command (back to defaults):
      winN.value = editCommandWindow.value.win
      label.value = { value: editCommandWindow.value.label, error: false }
      platform.value = editCommandWindow.value.platform
      terminals.value = editCommandWindow.value.terminal
      allowTerminalWrap.value = editCommandWindow.value.allowTerminalWrap
      allowProxychains.value = editCommandWindow.value.allowProxychains
      commandToRun.value = editCommandWindow.value.cmd

      if (editCommandWindow.value.code !== undefined) {
        codeDownloadOptions.value = editCommandWindow.value.code
      }

      // config property can be undefined
      configs.value =
        editCommandWindow.value.config === undefined
          ? []
          : editCommandWindow.value.config
    }, [
      codeDownloadOptions,
      allowTerminalWrap,
      allowProxychains,
      commandToRun,
      configs,
      editCommandWindow.value,
      label,
      platform,
      terminals,
      winN,
    ])

    const CommandConfigs = React.memo(() => {
      if (configs.value === undefined || configs.value.length < 1) {
        return
      }

      return configs.value.map((cfg) => {
        return (
          <ListItem
            key={`cmd-cfg-${cfg.props.label}`}
            sx={{
              border: '1px solid #cecece',
              display: 'flex',
              flexDirection: 'column',
              gap: '10px',
              ...(editConfig.value !== undefined &&
                editConfig.value === cfg && { background: '#4a2a00' }),
            }}
          >
            <Typography sx={{ wordWrap: 'break-word', width: '100%' }}>
              Command:{label.value.value} {cfg.props.label} | Replace='
              {cfg.replace}' with Default '{cfg.defaultValue.toString()}' as{' '}
              {cfg.props.type}
            </Typography>

            <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
              <Button
                variant="outlined"
                disabled={editConfig.value !== undefined}
                onClick={() => {
                  editConfig.value = cfg
                }}
              >
                <TuneIcon />
              </Button>

              <ConfirmDialog
                buttonText=""
                title={`Delete the Config Input '${cfg.props.label}' ?`}
                desc="Press Confirm to acknowledge and remove this Config Input from the current Command being edited/added. This will not be reversible once the Command edits are accepted."
                onConfirm={() => {
                  configs.value = configs.value.filter((f) => {
                    return !(
                      cfg.replace === f.replace &&
                      cfg.defaultValue === f.defaultValue &&
                      cfg.props.label === f.props.label &&
                      cfg.props.type === f.props.type
                    )
                  })
                }}
              />
            </Box>
          </ListItem>
        )
      })
    })

    return (
      <Box
        key={`commandOptions-${editorReset}`}
        sx={{
          width: '99%',
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          height: '100%',
          margin: '25px',
          padding: '15px',
          overflow: 'hidden',
        }}
      >
        {editCommandWindow.value === undefined && (
          <Box sx={{ display: 'flex', gap: '10px' }}>
            <Button
              color="success"
              variant="contained"
              onClick={handleOnAccept}
            >
              Accept NEW Command
            </Button>
            <ConfirmDialog
              buttonText="Reset Fields"
              title="Discard any edits to this Command?"
              desc="Press Confirm below to stop editing this Command and RESET all of the inputs back to defaults. ANY values not yet added to the json will be lost."
              onConfirm={() => {
                resetStateToDefaults()
              }}
            />
          </Box>
        )}

        {editCommandWindow.value !== undefined && (
          <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
            <Button color="warning" variant="contained" onClick={handleOnEdit}>
              Accept Edits to Command {label.value.value}
            </Button>

            <ConfirmDialog
              buttonText="Discard Edits"
              title="Discard any edits to this Command?"
              desc="Press Confirm below to stop editing this command, any config input changes and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
              onConfirm={() => {
                resetStateToDefaults()
              }}
            />
          </Box>
        )}

        <TextField
          label="Command Short Name"
          value={label.value.value}
          fullWidth
          error={label.value.error}
          helperText={
            label.value.error === true
              ? 'Must be a unique name within this set of commands'
              : ''
          }
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Help: Command Short Name`}>
                  <Typography>
                    The command short name is displayed when searching for
                    commands on the left side of the Configurator under the
                    search box. This value should be relatively short and still
                    convey which tool is being used in this command.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            const tmp = event.target.value

            const f = commandWindows.value.filter((cmd) => {
              return cmd.label.toLowerCase() === tmp.toLowerCase()
            })

            if (f.length > 0) {
              // must be unique
              label.value = { error: true, value: tmp }
            } else {
              label.value = { error: false, value: tmp }
            }
          }}
        />

        <NumberInput
          props={{
            fullWidth: true,
            label: 'Command Window Number',
            InputProps: {
              inputProps: { min: 0, max: 15 },
              startAdornment: (
                <InputAdornment position="start">
                  <AlertDialog title="Command Window Number Help">
                    <Typography>
                      The Command Window Number is a zero-indexed value that
                      indicates which window this command is expected to run in.
                      Typically a pentester has a terminal window setup with
                      several sub-windows or splits. To keep the commands
                      organized in a reasonable fashion, the Command Window
                      Number is used to determine which sub-window the command
                      should be run within. This allows creating many options
                      for the type of command the pentester wants to run, while
                      grouping like-commands together and eliminating confusion
                      in the UI.
                      <br />
                      <br />
                      TIP: use <CodeTypography>0</CodeTypography> for all of the
                      commands until a command needs to be run in parallel to
                      accomplish a goal and then increment the Command Window
                      Number for each parallel task required. Eg, use{' '}
                      <CodeTypography>0</CodeTypography> for all of the commands
                      which do the same task, and then increment to{' '}
                      <CodeTypography>0</CodeTypography> for setting up a
                      parallel task like running a server, which the{' '}
                      <CodeTypography>Command Window 0</CodeTypography> task
                      will potentially interact with during the pentest.
                      <br />
                      <br />
                      Min <CodeTypography>0</CodeTypography>, Max{' '}
                      <CodeTypography>15</CodeTypography>
                    </Typography>
                  </AlertDialog>
                </InputAdornment>
              ),
            },
            value: winN.value,
          }}
          numberChangeEvent={(n) => {
            winN.value = n
          }}
        />

        <TextField
          id="command-to-build-textinput"
          label="Command to build"
          value={commandToRun.value}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            commandToRun.value = event.target.value
          }}
          multiline
          fullWidth
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Building a Command`}>
                  <Typography>
                    To build a command enter an example command and then start
                    to replace static values with{' '}
                    <CodeTypography>__VALUE__</CodeTypography> type strings.
                    These can either come from the Global Replacements (eg
                    <CodeTypography>__ATTACKER_HOST__</CodeTypography>) or a
                    custom value defined by adding a Config Input. The value is
                    considered a global replacement even if it's within a config
                    input. This helps commands share common values between them.
                    If it's better to have the input value specific to this tool
                    one good convention is to prepend the tool name to the value
                    (eg <CodeTypography>__XFREERDP_USERNAME__</CodeTypography>).
                    Be sure to use the copy button next to the global
                    replacements values to avoid mistakes.
                    <br />
                    <br />
                    NOTE: Click on the <TravelExploreIcon /> to copy from the
                    Global Replacements list.
                  </Typography>
                </AlertDialog>
                <GlobalReplacementsDialog />
              </InputAdornment>
            ),
          }}
        />

        <TextField
          id="compiled-command"
          multiline
          fullWidth
          value={compiledCommand.value}
          label="Compiled Command Output"
          disabled
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Compiled Command Example`}>
                  <Typography>
                    This textfield will show what the command could look like
                    with example data plugged into the{' '}
                    <CodeTypography>__VALUE__</CodeTypography> replacement
                    strings.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />

        <Grid container>
          <Grid item xs={6}>
            <Autocomplete
              disablePortal
              options={PlatformOptions}
              sx={{ width: 'calc(100% - 20px)', margin: '10px' }}
              renderInput={(params) => (
                <TextField {...params} label={'Platform, aka OS'} />
              )}
              value={platform.value}
              onChange={(
                _event: React.SyntheticEvent,
                newValue: string | null
              ) => {
                if (
                  newValue === null ||
                  (newValue !== 'linux' &&
                    newValue !== 'linux|windows' &&
                    newValue !== 'windows')
                ) {
                  // default if somehow they select nothing or an unavailable option
                  platform.value = 'linux'
                  return
                }
                platform.value = newValue
              }}
            />

            <Autocomplete
              disablePortal
              multiple
              options={TerminalOptions}
              sx={{ width: 'calc(100% - 20px)', margin: '10px' }}
              renderInput={(params) => (
                <TextField {...params} label={'Terminal Options'} />
              )}
              value={terminals.value}
              onChange={(
                _event: React.SyntheticEvent,
                newValue: string[] | null
              ) => {
                if (newValue === null) {
                  // default if somehow they select nothing
                  terminals.value = ['sh', 'bash']
                  return
                }

                terminals.value = newValue as ('ps' | 'cmd' | 'sh' | 'bash')[]
              }}
            />
          </Grid>
          <Grid item xs={6}>
            <FormGroup>
              <FormControlLabel
                sx={{
                  userSelect: 'none',
                  width: 'calc(100% - 20px)',
                  margin: '10px',
                }}
                control={
                  <Checkbox
                    inputProps={{
                      'aria-label':
                        'Allow Terminal Wrap Options eg PS Base64 encoded command',
                    }}
                    checked={allowTerminalWrap.value}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                      allowTerminalWrap.value = event.target.checked
                    }}
                  />
                }
                label={
                  'Allow Terminal Wrap Options eg PS Base64 encoded command'
                }
              />
            </FormGroup>

            <FormGroup>
              <FormControlLabel
                sx={{
                  userSelect: 'none',
                  width: 'calc(100% - 20px)',
                  margin: '10px',
                }}
                control={
                  <Checkbox
                    inputProps={{
                      'aria-label':
                        'Allow Proxychains Options eg prepend command with proxychains',
                    }}
                    checked={allowProxychains.value}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                      allowProxychains.value = event.target.checked
                    }}
                  />
                }
                label={
                  'Allow Proxychains Options eg prepend command with proxychains'
                }
              />
            </FormGroup>
          </Grid>
        </Grid>

        <DownloadsEditor uniqueEntries={true} listState={codeDownloadOptions} />

        <Grid container>
          <Grid item xs={3}>
            <Typography variant="h5">Config Inputs:</Typography>
            <CommandConfigs />
          </Grid>
          <Grid item xs={9}>
            <ConfigsEditor configs={configs} editConfig={editConfig} />
          </Grid>
        </Grid>
      </Box>
    )
  }
)

export default CommandsEditor
