import React, { useEffect } from 'react'
import { useSignal, useComputed, Signal } from '@preact/signals-react'
import AlertDialog from '../../../../components/AlertDialog'
import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  Grid,
  InputAdornment,
  List,
  ListItem,
  TextField,
  Typography,
} from '@mui/material'
import {
  CMDConfigProps,
  CMDProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import NumberInput from '../../../../components/NumberInput'
import { globalReplacements } from '../../dataStructures'
import ConfigsEditor from '../ConfigsEditor'
import TravelExploreIcon from '@mui/icons-material/TravelExplore'
import TuneIcon from '@mui/icons-material/Tune'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import GlobalReplacementsDialog from '../../../../components/GlobalReplacementsDialog'
import DownloadsEditor from '../DownloadsEditor'
import { DownloadsProp } from '../DownloadsEditor/DownloadsEditor'
import CodeTypography from '../../../../components/CodeTypography'

import ConfigNumberTypeIcon from '@mui/icons-material/Calculate'
import ConfigStringTypeIcon from '@mui/icons-material/TextFields'
import ConfigCheckboxTypeIcon from '@mui/icons-material/CheckBox'
import ConfigSelectTypeIcon from '@mui/icons-material/ListAlt'
import ConfigRadioTypeIcon from '@mui/icons-material/RadioButtonChecked'
import HelpTextEditor from '../HelpTextEditor'

interface Props {
  editorReset: Signal<number>
  commandWindows: Signal<Array<CMDProps>>
  editCommandWindow: Signal<undefined | CMDProps>
}

const PlatformOptions = ['windows', 'linux', 'linux|windows']
const TerminalOptions: ('ps' | 'cmd' | 'sh' | 'bash')[] = [
  'ps',
  'cmd',
  'sh',
  'bash',
]

const CommandsEditor = React.memo(
  ({ commandWindows, editCommandWindow, editorReset }: Props) => {
    const winN = useSignal<number>(0)
    const commandToRun = useSignal<string>('')
    const commandHelpText = useSignal<string>('')

    const label = useSignal({ error: false, value: '' })
    const platform = useSignal<'windows' | 'linux' | 'linux|windows'>('linux')
    const terminals = useSignal<('ps' | 'cmd' | 'sh' | 'bash')[]>([
      'sh',
      'bash',
    ])
    const allowTerminalWrap = useSignal<boolean>(true)
    const allowProxychains = useSignal<boolean>(true)
    const configs = useSignal<Array<CMDConfigProps>>([])
    const editConfig = useSignal<undefined | CMDConfigProps>(undefined)
    const codeDownloadOptions = useSignal<Array<DownloadsProp>>([])

    const resetStateToDefaults = () => {
      // clear the values for the next command (back to defaults):
      winN.value = 0
      label.value = { value: '', error: false }
      platform.value = 'linux'
      terminals.value = ['sh', 'bash']
      allowTerminalWrap.value = true
      allowProxychains.value = true
      commandToRun.value = ''
      commandHelpText.value = ''
      codeDownloadOptions.value = []

      configs.value = []

      // get out of edit mode
      editCommandWindow.value = undefined
    }

    const handleOnAccept = () => {
      // this runs when the user has finished creating a new command and hit the accept button
      commandWindows.value = [
        ...commandWindows.value,
        {
          win: winN.value,
          label: label.value.value,
          platform: platform.value,
          terminal: terminals.value,
          allowTerminalWrap: allowTerminalWrap.value,
          allowProxychains: allowProxychains.value,
          cmd: commandToRun.value,
          help: commandHelpText.value,
          code: codeDownloadOptions.value,

          // config property can be undefined
          ...(configs.value.length > 0 && { config: configs.value }),
        },
      ]

      resetStateToDefaults()
    }

    const handleOnEdit = () => {
      // this runs when the user has finished editing and clicked the edit save button
      const updated = commandWindows.value.map((cmd) => {
        if (cmd === editCommandWindow.value) {
          return {
            win: winN.value,
            label: label.value.value,
            platform: platform.value,
            terminal: terminals.value,
            allowTerminalWrap: allowTerminalWrap.value,
            allowProxychains: allowProxychains.value,
            cmd: commandToRun.value,
            help: commandHelpText.value,
            code: codeDownloadOptions.value,

            // config property can be undefined
            ...(configs.value.length > 0 && { config: configs.value }),
          } as CMDProps
        }

        return cmd
      })

      commandWindows.value = updated

      resetStateToDefaults()
    }

    const compiledCommand = useComputed(() => {
      // this builds the command by replacing the __VALUE__ with their example inputs or their defaultValues
      let tmp = commandToRun.value

      globalReplacements.forEach((rep) => {
        tmp = tmp.replaceAll(rep.replace, rep.example)
      })
      return tmp
    })

    useEffect(() => {
      switch (platform.value) {
        case 'linux':
          terminals.value = ['sh', 'bash']
          break
        case 'windows':
          terminals.value = ['ps', 'cmd']
          break
        case 'linux|windows':
          terminals.value = ['ps', 'cmd', 'sh', 'bash']
          break
      }
    }, [platform.value, terminals])

    useEffect(() => {
      if (editCommandWindow.value === undefined) {
        return
      }

      // clear the values for the next command (back to defaults):
      winN.value = editCommandWindow.value.win
      label.value = { value: editCommandWindow.value.label, error: false }
      platform.value = editCommandWindow.value.platform
      terminals.value = editCommandWindow.value.terminal
      allowTerminalWrap.value = editCommandWindow.value.allowTerminalWrap
      allowProxychains.value = editCommandWindow.value.allowProxychains
      commandToRun.value = editCommandWindow.value.cmd
      commandHelpText.value = editCommandWindow.value.help

      if (editCommandWindow.value.code !== undefined) {
        codeDownloadOptions.value = editCommandWindow.value.code
      }

      // config property can be undefined
      configs.value =
        editCommandWindow.value.config === undefined
          ? []
          : editCommandWindow.value.config
    }, [
      codeDownloadOptions,
      allowTerminalWrap,
      allowProxychains,
      commandToRun,
      commandHelpText,
      configs,
      editCommandWindow.value,
      label,
      platform,
      terminals,
      winN,
    ])

    const CommandConfigs = React.memo(() => {
      if (configs.value === undefined || configs.value.length < 1) {
        return
      }

      return configs.value.map((cfg) => {
        // let TypeIcon = cfg.props.type
        let TypeIcon: React.ReactNode | string = cfg.props.type

        switch (cfg.props.type) {
          case 'number': {
            TypeIcon = <ConfigNumberTypeIcon />
            break
          }
          case 'string': {
            TypeIcon = <ConfigStringTypeIcon />

            break
          }
          case 'checkbox': {
            TypeIcon = <ConfigCheckboxTypeIcon />

            break
          }
          case 'select': {
            TypeIcon = <ConfigSelectTypeIcon />

            break
          }
          case 'radio': {
            TypeIcon = <ConfigRadioTypeIcon />

            break
          }
          default:
            console.log(
              'WARNING: cfg.props.type hit default, add the type and ICON to fix.'
            )
        }

        // ConfigNumberTypeIcon
        return (
          <ListItem
            key={`cmd-cfg-${cfg.props.label}`}
            sx={{
              border: '1px solid #cecece',
              display: 'flex',
              flexDirection: 'column',
              gap: '10px',
              ...(editConfig.value !== undefined &&
                editConfig.value === cfg && { background: '#4a2a00' }),
            }}
          >
            <Typography sx={{ wordWrap: 'break-word', width: '100%' }}>
              {TypeIcon} - {label.value.value} {cfg.props.label} | Replace='
              {cfg.replace}' with Default '{cfg.defaultValue.toString()}'
            </Typography>

            <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
              <Button
                variant="outlined"
                disabled={editConfig.value !== undefined}
                onClick={() => {
                  editConfig.value = cfg
                }}
              >
                <TuneIcon />
              </Button>

              <ConfirmDialog
                buttonText=""
                title={`Delete the Config Input '${cfg.props.label}' ?`}
                desc="Press Confirm to acknowledge and remove this Config Input from the current Command being edited/added. This will not be reversible once the Command edits are accepted."
                onConfirm={() => {
                  configs.value = configs.value.filter((f) => {
                    return !(
                      cfg.replace === f.replace &&
                      cfg.defaultValue === f.defaultValue &&
                      cfg.props.label === f.props.label &&
                      cfg.props.type === f.props.type
                    )
                  })
                }}
              />
            </Box>
          </ListItem>
        )
      })
    })

    return (
      <Box
        key={`commandOptions-${editorReset}`}
        sx={{
          width: '99%',
          display: 'flex',
          flexDirection: 'column',
          gap: '10px',
          height: '100%',
          margin: '25px',
          padding: '15px',
          overflow: 'hidden',
        }}
      >
        {editCommandWindow.value === undefined && (
          <Box sx={{ display: 'flex', gap: '10px' }}>
            <Button
              color="success"
              variant="contained"
              onClick={handleOnAccept}
            >
              Accept NEW Command
            </Button>
            <ConfirmDialog
              buttonText="Reset Fields"
              title="Discard any edits to this Command?"
              desc="Press Confirm below to stop editing this Command and RESET all of the inputs back to defaults. ANY values not yet added to the json will be lost."
              onConfirm={() => {
                resetStateToDefaults()
              }}
            />
          </Box>
        )}

        {editCommandWindow.value !== undefined && (
          <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
            <Button color="warning" variant="contained" onClick={handleOnEdit}>
              Accept Edits to Command {label.value.value}
            </Button>

            <ConfirmDialog
              buttonText="Discard Edits"
              title="Discard any edits to this Command?"
              desc="Press Confirm below to stop editing this command, any config input changes and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
              onConfirm={() => {
                resetStateToDefaults()
              }}
            />
          </Box>
        )}

        <Box display="flex">
          <TextField
            label="Command Short Name"
            value={label.value.value}
            fullWidth
            error={label.value.error}
            helperText={
              label.value.error === true
                ? 'Must be a unique name within this set of commands'
                : ''
            }
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <AlertDialog title={`Help: Command Short Name`}>
                    <Typography>
                      The command short name is displayed when searching for
                      commands on the left side of the Configurator under the
                      search box. This value should be relatively short and
                      still convey which tool is being used in this command.
                    </Typography>
                  </AlertDialog>
                </InputAdornment>
              ),
            }}
            onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
              const tmp = event.target.value

              const f = commandWindows.value.filter((cmd) => {
                return cmd.label.toLowerCase() === tmp.toLowerCase()
              })

              if (f.length > 0) {
                // must be unique
                label.value = { error: true, value: tmp }
              } else {
                label.value = { error: false, value: tmp }
              }
            }}
          />
          <HelpTextEditor
            helpText={commandHelpText}
            HelpEditingContextComponent={
              <>
                Command: <CodeTypography>{commandToRun.value}</CodeTypography>
              </>
            }
          />
        </Box>

        <NumberInput
          defaultValue={0}
          props={{
            fullWidth: true,
            label: 'Command Window Number',
            InputProps: {
              inputProps: { min: 0, max: 15 },
              startAdornment: (
                <InputAdornment position="start">
                  <AlertDialog title="Command Window Number Help">
                    <Typography>
                      The Command Window Number is a zero-indexed value that
                      indicates which window this command is expected to run in.
                      Typically a pentester has a terminal window setup with
                      several sub-windows or splits. To keep the commands
                      organized in a reasonable fashion, the Command Window
                      Number is used to determine which sub-window the command
                      should be run within. This allows creating many options
                      for the type of command the pentester wants to run, while
                      grouping like-commands together and eliminating confusion
                      in the UI.
                      <br />
                      <br />
                      TIP: use <CodeTypography>0</CodeTypography> for all of the
                      commands until a command needs to be run in parallel to
                      accomplish a goal and then increment the Command Window
                      Number for each parallel task required. Eg, use{' '}
                      <CodeTypography>0</CodeTypography> for all of the commands
                      which do the same task, and then increment to{' '}
                      <CodeTypography>0</CodeTypography> for setting up a
                      parallel task like running a server, which the{' '}
                      <CodeTypography>Command Window 0</CodeTypography> task
                      will potentially interact with during the pentest.
                      <br />
                      <br />
                      Min <CodeTypography>0</CodeTypography>, Max{' '}
                      <CodeTypography>15</CodeTypography>
                    </Typography>
                  </AlertDialog>
                </InputAdornment>
              ),
            },
            value: winN.value,
          }}
          numberChangeEvent={(n) => {
            winN.value = n
          }}
        />

        <TextField
          id="command-to-build-textinput"
          label="Command to build"
          value={commandToRun.value}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            commandToRun.value = event.target.value
          }}
          multiline
          fullWidth
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Building a Command`}>
                  <Typography>
                    To build a command enter an example command and then start
                    to replace static values with{' '}
                    <CodeTypography>__VALUE__</CodeTypography> type strings.
                    These can either come from the Global Replacements (eg
                    <CodeTypography>__ATTACKER_HOST__</CodeTypography>) or a
                    custom value defined by adding a Config Input. The value is
                    considered a global replacement even if it's within a config
                    input. This helps commands share common values between them.
                    If it's better to have the input value specific to this tool
                    one good convention is to prepend the tool name to the value
                    (eg <CodeTypography>__XFREERDP_USERNAME__</CodeTypography>).
                    Be sure to use the copy button next to the global
                    replacements values to avoid mistakes.
                    <br />
                    <br />
                    NOTE: Click on the <TravelExploreIcon /> to copy from the
                    Global Replacements list.
                  </Typography>
                </AlertDialog>
                <GlobalReplacementsDialog />
              </InputAdornment>
            ),
          }}
        />

        <TextField
          id="compiled-command"
          multiline
          fullWidth
          value={compiledCommand.value}
          label="Compiled Command Output"
          disabled
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Compiled Command Example`}>
                  <Typography>
                    This textfield will show what the command could look like
                    with example data plugged into the{' '}
                    <CodeTypography>__VALUE__</CodeTypography> replacement
                    strings.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />

        <Grid container>
          <Grid item xs={6}>
            <Box display={'flex'}>
              <AlertDialog title="Help: What is the Platform aka OS selection?">
                <Typography>
                  Currently this is an unused value. It's intent is to indicate
                  which type of system this command might run on. This can then
                  be used for additional features like the Terminal Wrap
                  Options, or deciding on which type of quotes might be better
                  to use. It also offers a simple way to filter the commands
                  that might be available to the pentester.
                </Typography>
              </AlertDialog>
              <Autocomplete
                disablePortal
                options={PlatformOptions}
                sx={{ width: 'calc(100% - 20px)', margin: '10px' }}
                renderInput={(params) => (
                  <TextField {...params} label={'Platform, aka OS'} />
                )}
                value={platform.value}
                onChange={(
                  _event: React.SyntheticEvent,
                  newValue: string | null
                ) => {
                  if (
                    newValue === null ||
                    (newValue !== 'linux' &&
                      newValue !== 'linux|windows' &&
                      newValue !== 'windows')
                  ) {
                    // default if somehow they select nothing or an unavailable option
                    platform.value = 'linux'
                    return
                  }
                  platform.value = newValue
                }}
              />
            </Box>

            <Box display={'flex'}>
              <AlertDialog title="Help: What are Terminal Options?">
                <Typography>
                  Currently this is an unused value. It's intent is to indicate
                  which terminal this command might run in. There can be very
                  subtle but problematic differences when doing certain tasks in
                  different terminals. This is aimed at helping the end-user
                  understand where this could be successfully run. Another
                  possible use for this info is with the Terminal Wrap Options
                  selection, this value could be used to filter which Terminal
                  Wraps Options are available to the end-user.
                </Typography>
              </AlertDialog>
              <Autocomplete
                disablePortal
                multiple
                options={TerminalOptions}
                sx={{ width: 'calc(100% - 20px)', margin: '10px' }}
                renderInput={(params) => (
                  <TextField {...params} label={'Terminal Options'} />
                )}
                value={terminals.value}
                onChange={(
                  _event: React.SyntheticEvent,
                  newValue: string[] | null
                ) => {
                  if (newValue === null) {
                    // default if somehow they select nothing
                    terminals.value = ['sh', 'bash']
                    return
                  }

                  terminals.value = newValue as ('ps' | 'cmd' | 'sh' | 'bash')[]
                }}
              />
            </Box>
          </Grid>
          <Grid item xs={6}>
            <Box display={'flex'}>
              <AlertDialog title="Help: What are Terminal Wrap Options?">
                <Typography>
                  Terminal Wrap Options allow the end user to take the entire
                  command-to-run and wrap it with a way to run that command via
                  something like{' '}
                  <CodeTypography>bash -c 'command'</CodeTypography> or the
                  PowerShell{' '}
                  <CodeTypography>powershell -enc "BASE64"</CodeTypography>
                  and many others! This is a very useful feature to a pentester
                  as it saves time with a common task. However, this list isn't
                  exhaustive and should be extended in the future. There is also
                  a potential issue with quotes, where the command isn't built
                  intelligently to escape quotes properly. See the GitHub issue
                  #9 for a discussion surrounding this improvement. At present,
                  the available Terminal Wrap Options are not filtered based on
                  the commands Platform or Terminal settings. This means that a
                  command could be wrapped with an option that will not run on
                  the specific target environment, and that no target
                  environment could exist with this combination. The end-user
                  needs to have enough situational awareness to understand what
                  they want to do, and where, to utilize this feature
                  appropriately.
                  <br />
                  <br />
                  When this checkbox is checked, the Terminal Wrap Options menu
                  will be shown for this Command. If this isn't appropriate,
                  uncheck this option. Default is checked
                </Typography>
              </AlertDialog>
              <FormGroup>
                <FormControlLabel
                  sx={{
                    userSelect: 'none',
                    width: 'calc(100% - 20px)',
                    margin: '10px',
                  }}
                  control={
                    <Checkbox
                      inputProps={{
                        'aria-label':
                          'Allow Terminal Wrap Options eg PS Base64 encoded command',
                      }}
                      checked={allowTerminalWrap.value}
                      onChange={(
                        event: React.ChangeEvent<HTMLInputElement>
                      ) => {
                        allowTerminalWrap.value = event.target.checked
                      }}
                    />
                  }
                  label={
                    'Allow Terminal Wrap Options eg PS Base64 encoded command'
                  }
                />
              </FormGroup>
            </Box>

            <Box display={'flex'}>
              <AlertDialog title="Help: Why allow Proxychains Options?">
                <Typography>
                  Proxychains is a command line tool that attempts to run a
                  command and force all network traffic through a proxy, or
                  network tunnel. There are numerous ways to configure a
                  Proxychains configuration, with the main goal typically being
                  to expose an internal network to an attacker controlled
                  computer. Tunneling is extremely powerful as it can allow for
                  the attacker computer to be utilized inside of an internal
                  network. Without a tunnel, an attack might need to install
                  software on a victim machine or find alternative ways to run
                  an attack on a compromised computer - this is often a very
                  difficult task as many things can cause problems such as no
                  internet access, no tools designed for this operating system
                  or the version of the installed programs isn't supported by
                  the necessary tools.
                  <br />
                  <br />
                  Checking this checkbox will enable a Proxychains dropdown menu
                  to be shown for the given Command. This will allow the
                  end-user to prepend different Proxychains commands to the
                  command-to-run. The various options available will allow for
                  things like running Proxychains in quiet mode or verbose mode.
                </Typography>
              </AlertDialog>
              <FormGroup>
                <FormControlLabel
                  sx={{
                    userSelect: 'none',
                    width: 'calc(100% - 20px)',
                    margin: '10px',
                  }}
                  control={
                    <Checkbox
                      inputProps={{
                        'aria-label':
                          'Allow Proxychains Options eg prepend command with proxychains',
                      }}
                      checked={allowProxychains.value}
                      onChange={(
                        event: React.ChangeEvent<HTMLInputElement>
                      ) => {
                        allowProxychains.value = event.target.checked
                      }}
                    />
                  }
                  label={
                    'Allow Proxychains Options eg prepend command with proxychains'
                  }
                />
              </FormGroup>
            </Box>
          </Grid>
        </Grid>

        <DownloadsEditor uniqueEntries={true} listState={codeDownloadOptions} />

        <Grid container>
          <Grid item xs={3}>
            <Typography variant="h5">Config Inputs:</Typography>
            <List sx={{ overflow: 'auto', maxHeight: '80vh' }}>
              <CommandConfigs />
            </List>
          </Grid>
          <Grid item xs={9}>
            <ConfigsEditor configs={configs} editConfig={editConfig} />
          </Grid>
        </Grid>
      </Box>
    )
  }
)

export default CommandsEditor
