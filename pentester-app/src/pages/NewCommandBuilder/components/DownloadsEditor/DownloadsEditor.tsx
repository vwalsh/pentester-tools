import { useSignal, Signal } from '@preact/signals-react'
import React from 'react'
import TextField from '@mui/material/TextField'
import List from '@mui/material/List'
import ListItem from '@mui/material/ListItem'
import IconButton from '@mui/material/IconButton'
import { Box, InputAdornment, Typography } from '@mui/material'
import AlertDialog from '../../../../components/AlertDialog'
import AddCircleOutlineIcon from '@mui/icons-material/AddCircleOutline'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import CopyItem from '../../../../components/CopyItem'
import CodeTypography from '../../../../components/CodeTypography'

export interface NameValueProp {
  filename: string
  data: string
}

interface Props {
  listState: Signal<Array<NameValueProp>>
  uniqueEntries: boolean
}

const DownloadsEditor = React.memo(({ listState, uniqueEntries }: Props) => {
  const input = useSignal<NameValueProp>({ data: '', filename: '' })
  const errors = useSignal<{
    name: boolean
    value: boolean
    validation: boolean
  }>({
    name: false,
    value: false,
    validation: false,
  })

  const handleAddEntry = () => {
    if (input.value) {
      const f = listState.value.filter(
        (item) =>
          item.data === input.value.data ||
          item.filename === input.value.filename
      )
      if (
        (uniqueEntries === true && f.length > 0) ||
        uniqueEntries === false ||
        input.value.filename === '' ||
        input.value.data === ''
      ) {
        errors.value = { ...errors.value, validation: true }
        return
      }

      listState.value = [...listState.value, input.value]
      input.value = { data: '', filename: '' }
    }
  }

  const handleNameChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    input.value = { ...input.value, filename: event.target.value }

    const f = listState.value.filter(
      (item) => item.filename === event.target.value
    )

    if ((uniqueEntries === true && f.length > 0) || uniqueEntries === false) {
      errors.value = { ...errors.value, name: true }
    } else {
      errors.value = { ...errors.value, name: false }
    }
  }

  const handleValueChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    input.value = { ...input.value, data: event.target.value }

    const f = listState.value.filter((item) => item.data === event.target.value)

    if ((uniqueEntries === true && f.length > 0) || uniqueEntries === false) {
      errors.value = { ...errors.value, value: true }
    } else {
      errors.value = { ...errors.value, value: false }
    }
  }

  const handleDeleteEntry = (index: number) => {
    const newList = listState.value.filter((_, i) => i !== index)
    listState.value = newList
  }

  return (
    <Box
      sx={{
        width: '100%',
        border: '1px solid #cecece',
        padding: '10px',
        borderRadius: '10px',
        margin: '5px',
      }}
    >
      <Typography variant="h6">
        Code Download Editor{'  '}
        {errors.value.validation && (
          <Typography sx={{ display: 'inline' }} color="error">
            ERROR: Both the Filename and Code input need a value set before this
            can be added.
          </Typography>
        )}
      </Typography>

      <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
        <TextField
          label="Filename"
          variant="outlined"
          value={input.value.filename}
          fullWidth
          error={errors.value.name}
          helperText={
            errors.value.name === true ? 'Unique filenames are required' : ''
          }
          onChange={handleNameChange}
          onKeyDown={(event: React.KeyboardEvent<HTMLDivElement>) => {
            if (event.key === 'Enter') {
              handleAddEntry()
            }
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title="Code Download Editor">
                  <Typography>
                    Add code here to allow the end-user to download any
                    necessary custom scripts or tools. Any code or file contents
                    needs to be converted to base64 encoding before being added
                    to the json.
                    <br />
                    <br />
                    Filename is a unique string value for the filename when
                    downloading the code.
                    <br />
                    <br />
                    Code is a base64 encoded string of the code to download.
                    This can be accomplished in various ways such as:
                    <br />
                    <br />
                  </Typography>

                  <CopyItem val={'base64 --wrap=0 ./file'}>
                    <CodeTypography>base64 --wrap=0 ./file</CodeTypography>
                  </CopyItem>
                  <CopyItem val={'cat ./file | base64 --wrap=0'}>
                    <CodeTypography>
                      cat ./file | base64 --wrap=0
                    </CodeTypography>
                  </CopyItem>
                  <CopyItem
                    val={`https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')&input=cGFzdGUgeW91ciBjb2RlIGhlcmUsIHRoZW4gY29weSB0aGUgb3V0cHV0`}
                  >
                    CyberChef Base64 Recipe URL
                  </CopyItem>
                  <Typography>
                    <br />
                    <br />
                    TIP: fill in the options and then press ENTER to add it to
                    the list.
                  </Typography>
                </AlertDialog>
                <IconButton
                  edge="end"
                  aria-label="add entry"
                  onClick={handleAddEntry}
                >
                  <AddCircleOutlineIcon />
                </IconButton>
              </InputAdornment>
            ),
          }}
        />
        <TextField
          label="Code"
          variant="outlined"
          value={input.value.data}
          fullWidth
          error={errors.value.value}
          helperText={
            errors.value.value === true
              ? 'Unique code entries are required'
              : ''
          }
          onChange={handleValueChange}
          onKeyDown={(event: React.KeyboardEvent<HTMLDivElement>) => {
            if (event.key === 'Enter') {
              handleAddEntry()
            }
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title="Code Download Editor: Code entry">
                  <Typography>
                    The file contents should be pasted into this field as a
                    base64 encoded string. This needs to be unique to avoid
                    duplicate code for the same command.
                    <br />
                    <br />
                    This can be accomplished in various ways such as:
                    <br />
                  </Typography>

                  <CopyItem val={'base64 --wrap=0 ./file'}>
                    <CodeTypography>base64 --wrap=0 ./file</CodeTypography>
                  </CopyItem>
                  <CopyItem val={'cat ./file | base64 --wrap=0'}>
                    <CodeTypography>
                      cat ./file | base64 --wrap=0
                    </CodeTypography>
                  </CopyItem>
                  <CopyItem
                    val={`https://gchq.github.io/CyberChef/#recipe=To_Base64('A-Za-z0-9%2B/%3D')&input=cGFzdGUgeW91ciBjb2RlIGhlcmUsIHRoZW4gY29weSB0aGUgb3V0cHV0`}
                  >
                    CyberChef Base64 Recipe URL
                  </CopyItem>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />
      </Box>

      <List>
        {listState.value.map((entry, index) => (
          <ListItem
            key={entry.filename}
            secondaryAction={
              <>
                <ConfirmDialog
                  title={`Delete '${entry.filename}'?`}
                  buttonText=""
                  desc="Once this is removed it cannot be undone. Are you sure?"
                  onConfirm={() => handleDeleteEntry(index)}
                />
              </>
            }
          >
            <Typography
              sx={{
                wordWrap: 'break-word',
                width: '80%',
                maxHeight: '4.5em',
                overflow: 'hidden',
                // userSelect: 'none',
              }}
            >
              {entry.filename}
            </Typography>
          </ListItem>
        ))}
      </List>
    </Box>
  )
})

export default DownloadsEditor
