import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  InputAdornment,
  TextField,
  Typography,
} from '@mui/material'
import { useSignal, Signal } from '@preact/signals-react'
import React, { useCallback, useEffect } from 'react'
import AlertDialog from '../../../../components/AlertDialog'
import StringConfigToolEditor from './components/StringConfigToolEditor'
import NumberConfigToolEditor from './components/NumberConfigToolEditor'
import CheckboxConfigToolEditor from './components/CheckboxConfigToolEditor'
import SelectConfigToolEditor from './components/SelectConfigToolEditor'
import {
  CMDConfigProps,
  CheckboxInputProps,
  NumberInputProps,
  StringInputProps,
  SelectInputProps,
  RadioInputProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import SuccessTooltip from '../../../../components/SuccessTooltip'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import RadioGroupEditor from './components/RadioGroupEditor'
import { RadioGroupProp } from './components/RadioGroupEditor/RadioGroupEditor'
import CodeTypography from '../../../../components/CodeTypography'

const ConfigInputTypes = ['string', 'number', 'checkbox', 'select', 'radio']

export interface DefaultValueProps {
  value: string | number | boolean
  error: boolean
}

interface Props {
  configs: Signal<Array<CMDConfigProps>>
  editConfig: Signal<undefined | CMDConfigProps>
}

const ConfigsEditor = React.memo(({ configs, editConfig }: Props) => {
  const addedConfigInputTooltipOpen = useSignal<boolean>(false)
  const inputType = useSignal<string>('string')
  const defaultValue = useSignal<DefaultValueProps>({ value: '', error: false })
  const cmdLabel = useSignal<string>('')
  const helpText = useSignal<string>('')
  const replace = useSignal({ value: '', error: false })

  // type=='string'
  const validationRegex = useSignal<string>('')
  const validationHelp = useSignal<string>('')

  // type=='number'
  const minNum = useSignal<number>(1)
  const maxNum = useSignal<number>(65535)

  // type=='checkbox'
  const replaceValue = useSignal<string>('')

  // type=='select'
  const customInput = useSignal<boolean>(false)
  const optionsList = useSignal<Array<string>>([])

  // type=='radio'
  const radioList = useSignal<Array<RadioGroupProp>>([])
  const _defaultRadioOption = useSignal<RadioGroupProp>({
    label: '',
    replace: '',
  })

  const resetStateToDefaults = useCallback(
    (isEditing: boolean = false) => {
      // reset all the values!
      inputType.value = 'string'
      defaultValue.value = { value: '', error: false }
      cmdLabel.value = ''
      helpText.value = ''
      replace.value = { value: '', error: false }

      // type=='string'
      validationRegex.value = ''
      validationHelp.value = ''

      // type=='number'
      minNum.value = 1
      maxNum.value = 65535

      // type=='checkbox'
      replaceValue.value = ''

      // type=='select'
      customInput.value = false
      optionsList.value = []

      // type='radio'
      radioList.value = []
      _defaultRadioOption.value = { label: '', replace: '' }

      if (isEditing === false) {
        // reset out of edit mode if not currently starting to edit
        editConfig.value = undefined
      }
    },
    [
      cmdLabel,
      customInput,
      defaultValue,
      editConfig,
      helpText,
      inputType,
      maxNum,
      minNum,
      optionsList,
      radioList,
      _defaultRadioOption,
      replace,
      replaceValue,
      validationHelp,
      validationRegex,
    ]
  )

  const getConfig = useCallback((): CMDConfigProps => {
    let props:
      | NumberInputProps
      | StringInputProps
      | CheckboxInputProps
      | SelectInputProps
      | RadioInputProps
      | undefined = undefined

    let defaultValueProp = defaultValue.value.value

    if (inputType.value === 'string') {
      props = {
        type: 'string',
        label: cmdLabel.value,
      } as StringInputProps
    }
    if (inputType.value === 'number') {
      props = {
        type: 'number',
        label: cmdLabel.value,
        InputProps: {
          inputProps: { min: minNum.value, max: maxNum.value },
        },
      } as NumberInputProps
    }

    if (inputType.value === 'checkbox') {
      defaultValueProp = !!defaultValue.value.value
      props = {
        type: 'checkbox',
        label: cmdLabel.value,
        replaceValue: replaceValue.value,
      } as CheckboxInputProps
    }

    if (inputType.value === 'select') {
      props = {
        type: 'select',
        label: cmdLabel.value,
        customInput: customInput.value,
        options: optionsList.value,
      } as SelectInputProps
    }

    if (inputType.value === 'radio') {
      defaultValueProp = _defaultRadioOption.value.replace
      props = {
        type: 'radio',
        options: radioList.value,
        label: cmdLabel.value,
      } as RadioInputProps
    }

    if (props === undefined) {
      throw new Error(
        'config input type not found above, props undefined. stopping'
      )
    }

    return {
      help: helpText.value,
      replace: replace.value.value,
      defaultValue: defaultValueProp,

      // conditionally add the validationRegex and validationHelp properties if this is a string type input
      ...(inputType.value === 'string' && {
        validationRegex: validationRegex.value,
        validationHelp: validationHelp.value,
      }),

      props: {
        ...props,
      },
    } as CMDConfigProps
  }, [
    cmdLabel.value,
    customInput.value,
    defaultValue.value.value,
    helpText.value,
    inputType.value,
    maxNum.value,
    minNum.value,
    optionsList.value,
    radioList.value,
    _defaultRadioOption.value.replace,
    replace.value.value,
    replaceValue.value,
    validationHelp.value,
    validationRegex.value,
  ])

  const handleUpdate = (isEditing: boolean = false) => {
    const newCfg = getConfig()

    if (isEditing === false) {
      configs.value = [...configs.value, newCfg]
    } else {
      const updated = configs.value.map((cfg) => {
        if (cfg === editConfig.value) {
          return newCfg
        }
        return cfg
      })
      configs.value = updated
    }

    resetStateToDefaults()
    // set tooltip to shown
    addedConfigInputTooltipOpen.value = true
  }

  useEffect(() => {
    if (addedConfigInputTooltipOpen.value === false) {
      return
    }

    const timer1 = setTimeout(() => {
      addedConfigInputTooltipOpen.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  }, [addedConfigInputTooltipOpen, addedConfigInputTooltipOpen.value])

  useEffect(() => {
    if (editConfig.value === undefined) {
      return
    }

    resetStateToDefaults(true)

    inputType.value = editConfig.value.props.type
    defaultValue.value = { value: editConfig.value.defaultValue, error: false }
    cmdLabel.value = editConfig.value.props.label
    helpText.value = editConfig.value.help
    replace.value = { value: editConfig.value.replace, error: false }

    // type=='string'
    validationRegex.value =
      editConfig.value.validationRegex === undefined
        ? ''
        : editConfig.value.validationRegex
    validationHelp.value =
      editConfig.value.validationHelp === undefined
        ? ''
        : editConfig.value.validationHelp

    // type=='number'
    if (editConfig.value.props.type === 'number') {
      const iprops = editConfig.value.props?.InputProps?.inputProps
      // if (iprops !== undefined) {
      minNum.value = iprops?.min === undefined ? 1 : iprops.min
      maxNum.value = iprops?.max === undefined ? 65535 : iprops.max
      // }
    }

    // type=='checkbox'
    if (editConfig.value.props.type === 'checkbox') {
      replaceValue.value =
        editConfig.value.props?.replaceValue === undefined
          ? ''
          : editConfig.value.props.replaceValue
    }

    if (editConfig.value.props.type === 'select') {
      // type=='select'
      customInput.value =
        editConfig.value.props?.customInput === undefined
          ? false
          : editConfig.value.props.customInput
      optionsList.value =
        editConfig.value.props?.options === undefined
          ? []
          : editConfig.value.props.options
    }
  }, [
    cmdLabel,
    customInput,
    defaultValue,
    editConfig.value,
    helpText,
    inputType,
    maxNum,
    minNum,
    optionsList,
    replace,
    replaceValue,
    resetStateToDefaults,
    validationHelp,
    validationRegex,
  ])

  // type='select'
  // set the default select option selection when the select list length is > 1 AND the default select option is the initial value
  useEffect(() => {
    if (optionsList.value === undefined || optionsList.value.length < 1) {
      return
    }

    if (defaultValue.value.value === '' && customInput.value === false) {
      defaultValue.value = { value: optionsList.value[0], error: false }
    }
  }, [defaultValue, defaultValue.value, optionsList.value, customInput])

  // type='radio'
  // set the default radio option selection when the radio list length is > 1 AND the default radio option is the initial value
  useEffect(() => {
    if (radioList.value === undefined || radioList.value.length < 1) {
      return
    }

    if (_defaultRadioOption.value.label === '') {
      _defaultRadioOption.value = radioList.value[0]
    }
  }, [_defaultRadioOption, _defaultRadioOption.value, radioList.value])

  return (
    <Box
      sx={{
        gap: '10px',
        display: 'flex',
        flexDirection: 'column',
        margin: '10px',
      }}
    >
      <Typography variant="h5">
        Config Input Editor for current Command
        <AlertDialog title={`Help: What is a Config Input?`}>
          <Typography>
            Config Inputs are interactive input components that allow the
            end-user to configure the command-to-run with guidance on the
            options available. Config inputs sole purpose is to help gather
            valid values to place into the command. Each Config Input is focused
            on replacing a <CodeTypography>__VALUE__</CodeTypography> within the
            command-to-run.
            <br />
            <br />
            TIP: Config Inputs can also setup more{' '}
            <CodeTypography>__VALUE__</CodeTypography> to replace from another
            Config Input. Put another way, Config Inputs can 'stack' or
            'cascade' their modifications to the command-to-run. A common way
            this is used is first by creating a Checkbox Config Input and then
            creating a String Config Input. The checkbox will allow the end-user
            to disable or enable an entire flag for the command-to-run while the
            string input will allow for validation of the input values.
          </Typography>
        </AlertDialog>
      </Typography>

      <TextField
        id="config-label"
        multiline
        fullWidth
        label="Short name for this config input"
        value={cmdLabel.value}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          cmdLabel.value = event.target.value
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Help: Short name for this config input`}>
                <Typography>
                  This is a label or short name shown for this given input. This
                  will help the user understand what value they are entering.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      <TextField
        id="config-help"
        multiline
        fullWidth
        label="Help Text for Command"
        value={helpText.value}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          helpText.value = event.target.value
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Help Text Entry`}>
                <Typography>
                  The help text for this given input. Be sure to describe what
                  this replacement value does for the command.
                  <br />
                  <br />
                  TIP: Pairing a Checkbox with another input can allow for
                  enabling or disabling an entire command flag.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      <TextField
        id="config-replace"
        fullWidth
        label="Replacement Value in Command (typically includes __VALUE__)"
        value={replace.value.value}
        error={replace.value.error}
        helperText={
          replace.value.error === true ? 'Uniqueness is required' : ''
        }
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          // enforce that replace values need to be unique
          const tmp = event.target.value
          const f = configs.value.filter((cfg) => {
            return cfg.replace === tmp
          })
          if (f.length > 0) {
            replace.value = { value: tmp, error: true }
          } else {
            replace.value = { value: tmp, error: false }
          }
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Replace Value in Command`}>
                <Typography>
                  The variable name aka value to replace within the command
                  string. Uniqueness is enforced to reduce the chances of odd
                  user experiences.
                  <br />
                  <br />
                  Typical format is{' '}
                  <CodeTypography>__VALUE_NAME__</CodeTypography> (double
                  underscore, capital-case variable name with underscores for
                  separators ending with a double underscore) for each value to
                  replace. However this value can be any string. This would
                  replace the
                  <CodeTypography>__VALUE_NAME__</CodeTypography> within the
                  command with the given input type data, eg '10' for a number
                  input.
                  <br />
                  <br />
                  TIP: Pairing a Checkbox with another input can allow for
                  enabling or disabling an entire command flag.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      {/* enabled for:
          1. string input
          2. number input
          3. when the Custom Input checkbox is checked
       */}
      {(inputType.value === 'string' ||
        inputType.value === 'number' ||
        customInput.value === true) && (
        <TextField
          id="config-defaultValue-number-string-customInput"
          fullWidth
          label="Default Value for this Replacement Value"
          value={defaultValue.value.value}
          error={defaultValue.value.error}
          helperText={defaultValue.value.error === true ? '' : ''}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            if (inputType.value === 'number') {
              defaultValue.value = {
                value: parseInt(event.target.value),
                error: false,
              }
            } else if (inputType.value === 'string') {
              // TODO: does this need to be validated against the regex if provided?
              defaultValue.value = { value: event.target.value, error: false }
            } else if (inputType.value === 'select') {
              defaultValue.value = { value: event.target.value, error: false }
            }
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Help: Default Value`}>
                  <Typography>
                    The Default Value to start this Command Config input with.
                    This is either a string or a number depending on the Config
                    Input type.
                    <br />
                    <br /> For a <CodeTypography>string</CodeTypography> input
                    type, this is commonly set to blank (all input cleared).
                    <br />
                    <br /> For a <CodeTypography>number</CodeTypography> input
                    type, this is commonly the minimum or a sane value between
                    the min and max.
                    <br />
                    <br />
                    For a <CodeTypography>select</CodeTypography> input type
                    with the <CodeTypography>custom text input</CodeTypography>{' '}
                    option selected, this can be any text value.
                    <br />
                    <br />
                    TIP: As a <CodeTypography>string</CodeTypography> or{' '}
                    <CodeTypography>select</CodeTypography> input type, this
                    value can include another
                    <CodeTypography>__VALUE__</CodeTypography> variable to
                    replace via another Command Config input.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />
      )}

      <Box sx={{ display: 'flex' }}>
        <AlertDialog title={`Help: Command Config input types`}>
          <Typography>
            Command Configs can have various input types offered to the user.
            Each has it's own UI elements associated. Each has a common use-case
            for the user as well.
            <br />
            <br />
            <CodeTypography>string</CodeTypography> input type allows the end
            user to be given a text input to type into. The user can even
            include <CodeTypography>__VALUE__</CodeTypography> named values to
            have replaced in the command-to-run. A validation regex can be
            configured to reject invalid input, however this is optional as the
            default is to accept all input.
            <br />
            <br />
            <CodeTypography>number</CodeTypography> input type allows for the
            end user to choose a number, within a valid min to max range, and
            have this number inserted into the command-to-run. This reduces the
            chance for typos as well as helps manage things like port numbers a
            little easier.
            <br />
            <br />
            <CodeTypography>checkbox</CodeTypography> input type allows for the
            end user to make a binary decision, eg enable a flag for a command
            or remove it entirely. Checkboxes often have replacement values that
            include additional <CodeTypography>__VALUE__</CodeTypography>{' '}
            variables, and then the command is configured with other inputs to
            fill in all the variables the checkbox inserted. Eg, a checkbox
            turns on a flag which requires both a username and password for
            authentication. For the best user experience they would also be
            given String inputs, one for username and one for the password
            values.
            <br />
            <br />
            <CodeTypography>select</CodeTypography> input type allows for the
            end user to be given options to choose from, or potentially type in
            their own values (if custom input is enabled). This type of input is
            best to help guide a user to the only available options or give them
            the freedom to type in a custom option.
            <br />
            <br />
            <CodeTypography>radio</CodeTypography> input type allows for the end
            user to choose one and only one option from multiple options. Think
            of it like a multiple-choice answer to a question. This type of
            input is best used when a set of flags can be enabled, but only one
            can be enabled at a time. Eg, a Radio input is configured with
            options for adding a password flag to the command or adding a
            pass-the-hash flag to the command. Radio input type is like an Array
            of Checkbox inputs. When an Radio option is selected by the
            end-user, the replacement value is inserted into the command-to-run.
            This means that each Radio option has an replacement value to insert
            which can include additional values to replace - those sub values
            are paired with additional inputs such as a String input to have the
            end-user build a complete command.
          </Typography>
        </AlertDialog>

        <Autocomplete
          disablePortal
          options={ConfigInputTypes}
          disableClearable
          sx={{ width: 300 }}
          renderInput={(params) => (
            <TextField {...params} label={'Command Config input type'} />
          )}
          value={inputType.value}
          onChange={(_event: React.SyntheticEvent, newValue: string | null) => {
            if (newValue === null) {
              // default if somehow they select nothing
              inputType.value = 'string'
              return
            }
            inputType.value = newValue
          }}
        />
      </Box>

      {inputType.value === 'checkbox' && (
        <>
          <Box sx={{ display: 'flex' }}>
            <AlertDialog title="Help: Default Checkbox State">
              <Typography>
                The default checkbox state determines if the checkbox by default
                is checked or not. This means that when the user first selects
                this command, is the checkbox automatically enabled (checked) or
                unchecked. If checked, this means the flag this checkbox enables
                is on by default.
              </Typography>
            </AlertDialog>
            <FormGroup>
              <FormControlLabel
                sx={{ userSelect: 'none' }}
                control={
                  <Checkbox
                    inputProps={{ 'aria-label': 'Default Checkbox state' }}
                    checked={!!defaultValue.value.value}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                      defaultValue.value = {
                        value: event.target.checked,
                        error: false,
                      }
                    }}
                  />
                }
                label={'Default Checkbox state'}
              />
            </FormGroup>
          </Box>
        </>
      )}

      {/* only display the editor for the given input type */}
      {inputType.value === 'string' && (
        <StringConfigToolEditor
          validationRegex={validationRegex}
          validationHelp={validationHelp}
        />
      )}
      {inputType.value === 'number' && (
        <NumberConfigToolEditor minNum={minNum} maxNum={maxNum} />
      )}
      {inputType.value === 'checkbox' && (
        <CheckboxConfigToolEditor replaceValue={replaceValue} />
      )}
      {inputType.value === 'select' && (
        <>
          <SelectConfigToolEditor
            customInput={customInput}
            optionsList={optionsList}
            defaultValue={defaultValue}
            onDefaultValueChange={(newDefaultValue: string) => {
              defaultValue.value = {
                value: newDefaultValue,
                error: false,
              }
            }}
          />
        </>
      )}

      {inputType.value === 'radio' && (
        <>
          <RadioGroupEditor listState={radioList} uniqueEntries={true} />

          <Box sx={{ display: 'flex' }}>
            <AlertDialog title="Help: Default Radio Button Options default selected option">
              <Typography>
                Choose a default selected option from the list of options
                entered into the Radio Button Options Editor. This will be
                selected when the user first loads this Config Input after
                selecting a Command.
              </Typography>
            </AlertDialog>
            <Autocomplete
              disablePortal
              options={radioList.value as Array<RadioGroupProp>}
              // disableClearable
              sx={{ width: '100%' }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label={'Default Selected Radio Button Option'}
                />
              )}
              value={_defaultRadioOption.value}
              onChange={(
                _event: React.SyntheticEvent,
                newValue: RadioGroupProp | null
              ) => {
                if (newValue === null) {
                  // default if somehow they select nothing
                  defaultValue.value = {
                    value:
                      radioList.value.length < 1
                        ? ''
                        : radioList.value[0].label,
                    error: false,
                  }
                } else {
                  _defaultRadioOption.value = newValue
                }
              }}
              isOptionEqualToValue={function (
                option: RadioGroupProp,
                value: RadioGroupProp
              ) {
                if (option.label === value.label) {
                  return true
                }
                // to fix a bug with no option selected
                if (value.label === '' && value.replace === '') {
                  return true
                }

                return false
              }}
            />
          </Box>
        </>
      )}

      <SuccessTooltip
        open={addedConfigInputTooltipOpen.value}
        title="Added!"
        placement="left"
      >
        <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
          {editConfig.value === undefined && (
            <Button
              color="success"
              variant="contained"
              onClick={() => {
                handleUpdate(false)
              }}
            >
              Add NEW Config Input to Command
            </Button>
          )}

          {editConfig.value !== undefined && (
            <>
              <Button
                color="warning"
                variant="contained"
                onClick={() => {
                  handleUpdate(true)
                }}
              >
                Edit Config Input for Command
              </Button>

              <ConfirmDialog
                buttonText="Discard Edits"
                title="Discard any edits to this Config Input?"
                desc="Press Confirm below to stop editing this config input and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
                onConfirm={() => {
                  resetStateToDefaults()
                }}
              />
            </>
          )}

          <ConfirmDialog
            buttonText="RESET Fields"
            title="RESET Config Input Editor fields?"
            desc="Press Confirm below to RESET all of the inputs. ANY edited inputs not yet added to the json will be lost."
            onConfirm={() => {
              resetStateToDefaults()
            }}
          />
        </Box>
      </SuccessTooltip>
    </Box>
  )
})

export default ConfigsEditor
