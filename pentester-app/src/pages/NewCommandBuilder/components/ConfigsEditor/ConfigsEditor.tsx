import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  InputAdornment,
  TextField,
  Typography,
} from '@mui/material'
import { useSignal, Signal, useComputed } from '@preact/signals-react'
import React, { useCallback, useEffect } from 'react'
import AlertDialog from '../../../../components/AlertDialog'
import StringConfigToolEditor from './components/StringConfigToolEditor'
import NumberConfigToolEditor from './components/NumberConfigToolEditor'
import CheckboxConfigToolEditor from './components/CheckboxConfigToolEditor'
import SelectConfigToolEditor from './components/SelectConfigToolEditor'
import {
  CMDConfigProps,
  CheckboxInputProps,
  NumberInputProps,
  StringInputProps,
  SelectInputProps,
  RadioInputProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import SuccessTooltip from '../../../../components/SuccessTooltip'
import ConfirmDialog from '../../../../components/ConfirmDialog'
import RadioGroupEditor from './components/RadioGroupEditor'
import { RadioGroupProp } from './components/RadioGroupEditor/RadioGroupEditor'
import CodeTypography from '../../../../components/CodeTypography'
import HelpTextEditor from '../HelpTextEditor'
import {
  globalReplacements,
  globalSpecialReplacements,
} from '../../dataStructures'
import NumberInput from '../../../../components/NumberInput'

const ConfigInputTypes = ['string', 'number', 'checkbox', 'select', 'radio']

export interface DefaultValueProps {
  value: string | number | boolean
  error: string
}

interface Props {
  configs: Signal<Array<CMDConfigProps>>
  editConfig: Signal<undefined | CMDConfigProps>
}

const ConfigsEditor = React.memo(({ configs, editConfig }: Props) => {
  const addedConfigInputTooltipOpen = useSignal<boolean>(false)
  const inputType = useSignal<string>('string')
  const defaultValue = useSignal<DefaultValueProps>({ value: '', error: '' })
  const cmdLabel = useSignal<string>('')
  const helpText = useSignal<string>('')
  const replace = useSignal({ value: '', error: '' }) // can handle custom error messages when this is a string

  // type=='string'
  const validationRegex = useSignal<string>('')
  const validationHelp = useSignal<string>('')

  // type=='number'
  const minNum = useSignal<number>(1)
  const maxNum = useSignal<number>(65535)

  // type=='checkbox'
  const replaceValue = useSignal<string>('')

  // type=='select'
  const customInput = useSignal<boolean>(false)
  const optionsList = useSignal<Array<string>>([])

  // type=='radio'
  const radioList = useSignal<Array<RadioGroupProp>>([])

  const allowSave = useComputed(() => {
    let tmp = true

    if (inputType.value === 'number') {
      // && typeof defaultValue.value.value === 'number'){
      const n = parseInt(defaultValue.value.value.toString())
      if (n < minNum.value || n > maxNum.value || minNum.value > maxNum.value) {
        tmp = false
      }
    }

    // this is used to disable a button so flipping the overall output is required (disabled==true means disabled)
    // return (cmdLabel.value !== '' && replace.value.value === '' && replace.value.error !== '' && defaultValue.value.error !== '' && tmp === true) === false
    if (
      cmdLabel.value !== '' &&
      replace.value.value !== '' &&
      replace.value.error === '' &&
      defaultValue.value.error === '' &&
      tmp === true
    ) {
      return true
    }

    return false
  })

  const resetStateToDefaults = useCallback(
    (isEditing: boolean = false) => {
      // reset all the values!
      inputType.value = 'string'
      defaultValue.value = { value: '', error: '' }
      cmdLabel.value = ''
      helpText.value = ''
      replace.value = { value: '', error: '' }

      // type=='string'
      validationRegex.value = ''
      validationHelp.value = ''

      // type=='number'
      minNum.value = 1
      maxNum.value = 65535

      // type=='checkbox'
      replaceValue.value = ''

      // type=='select'
      customInput.value = false
      optionsList.value = []

      // type='radio'
      radioList.value = []

      if (isEditing === false) {
        // reset out of edit mode if not currently starting to edit
        editConfig.value = undefined
      }
    },
    [
      cmdLabel,
      customInput,
      defaultValue,
      editConfig,
      helpText,
      inputType,
      maxNum,
      minNum,
      optionsList,
      radioList,
      replace,
      replaceValue,
      validationHelp,
      validationRegex,
    ]
  )

  const getConfig = useCallback((): CMDConfigProps => {
    let props:
      | NumberInputProps
      | StringInputProps
      | CheckboxInputProps
      | SelectInputProps
      | RadioInputProps
      | undefined = undefined

    let defaultValueProp = defaultValue.value.value

    if (inputType.value === 'string') {
      props = {
        type: 'string',
        label: cmdLabel.value,
      } as StringInputProps
    }
    if (inputType.value === 'number') {
      props = {
        type: 'number',
        label: cmdLabel.value,
        InputProps: {
          inputProps: { min: minNum.value, max: maxNum.value },
        },
      } as NumberInputProps
    }

    if (inputType.value === 'checkbox') {
      defaultValueProp = !!defaultValue.value.value
      props = {
        type: 'checkbox',
        label: cmdLabel.value,
        replaceValue: replaceValue.value,
      } as CheckboxInputProps
    }

    if (inputType.value === 'select') {
      props = {
        type: 'select',
        label: cmdLabel.value,
        customInput: customInput.value,
        options: optionsList.value,
      } as SelectInputProps
    }

    if (inputType.value === 'radio') {
      // defaultValueProp = _defaultRadioOption.value.replace
      props = {
        type: 'radio',
        options: radioList.value,
        label: cmdLabel.value,
      } as RadioInputProps
    }

    if (props === undefined) {
      throw new Error(
        'config input type not found above, props undefined. stopping'
      )
    }

    return {
      help: helpText.value,
      replace: replace.value.value,
      defaultValue: defaultValueProp,

      // conditionally add the validationRegex and validationHelp properties if this is a string type input
      ...(inputType.value === 'string' && {
        validationRegex: validationRegex.value,
        validationHelp: validationHelp.value,
      }),

      props: {
        ...props,
      },
    } as CMDConfigProps
  }, [
    cmdLabel.value,
    customInput.value,
    defaultValue.value.value,
    helpText.value,
    inputType.value,
    maxNum.value,
    minNum.value,
    optionsList.value,
    radioList.value,
    replace.value.value,
    replaceValue.value,
    validationHelp.value,
    validationRegex.value,
  ])

  const handleUpdate = (isEditing: boolean = false) => {
    const newCfg = getConfig()

    if (isEditing === false) {
      configs.value = [...configs.value, newCfg]
    } else {
      const updated = configs.value.map((cfg) => {
        if (cfg === editConfig.value) {
          return newCfg
        }
        return cfg
      })
      configs.value = updated
    }

    resetStateToDefaults()
    // set tooltip to shown
    addedConfigInputTooltipOpen.value = true
  }

  useEffect(() => {
    if (addedConfigInputTooltipOpen.value === false) {
      return
    }

    const timer1 = setTimeout(() => {
      addedConfigInputTooltipOpen.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  }, [addedConfigInputTooltipOpen, addedConfigInputTooltipOpen.value])

  useEffect(() => {
    if (editConfig.value === undefined) {
      return
    }

    resetStateToDefaults(true)

    inputType.value = editConfig.value.props.type
    defaultValue.value = { value: editConfig.value.defaultValue, error: '' }
    cmdLabel.value = editConfig.value.props.label
    helpText.value = editConfig.value.help
    replace.value = { value: editConfig.value.replace, error: '' }

    // type=='string'
    validationRegex.value =
      editConfig.value.validationRegex === undefined
        ? ''
        : editConfig.value.validationRegex
    validationHelp.value =
      editConfig.value.validationHelp === undefined
        ? ''
        : editConfig.value.validationHelp

    switch (editConfig.value.props.type) {
      case 'number': {
        // type=='number'
        const iprops = editConfig.value.props?.InputProps?.inputProps
        minNum.value = iprops?.min === undefined ? 1 : iprops.min
        maxNum.value = iprops?.max === undefined ? 65535 : iprops.max
        break
      }
      case 'string': {
        break
      }
      case 'checkbox': {
        // type=='checkbox'
        replaceValue.value =
          editConfig.value.props?.replaceValue === undefined
            ? ''
            : editConfig.value.props.replaceValue
        break
      }
      case 'radio': {
        // type=='radio'
        radioList.value =
          editConfig.value.props?.options === undefined
            ? []
            : editConfig.value.props.options

        break
      }
      case 'select': {
        // type=='select'
        customInput.value =
          editConfig.value.props?.customInput === undefined
            ? false
            : editConfig.value.props.customInput
        optionsList.value =
          editConfig.value.props?.options === undefined
            ? []
            : editConfig.value.props.options

        break
      }
      default:
        throw new Error('editConfig.value.props.type unaccounted for!')
    }
  }, [
    cmdLabel,
    customInput,
    defaultValue,
    editConfig.value,
    helpText,
    inputType,
    maxNum,
    minNum,
    optionsList,
    radioList,
    replace,
    replaceValue,
    resetStateToDefaults,
    validationHelp,
    validationRegex,
  ])

  // type='select'
  // set the default select option selection when the select list length is > 1 AND the default select option is the initial value
  useEffect(() => {
    if (optionsList.value === undefined || optionsList.value.length < 1) {
      return
    }

    if (defaultValue.value.value === '' && customInput.value === false) {
      defaultValue.value = { value: optionsList.value[0], error: '' }
    }
  }, [defaultValue, defaultValue.value, optionsList.value, customInput])

  // type='number'
  // set the default value if it's blank - it must be at or within the min/max range
  useEffect(() => {
    if (defaultValue.value.value === '' && inputType.value === 'number') {
      defaultValue.value = { value: minNum.value, error: '' }
    }
  }, [defaultValue, defaultValue.value, minNum.value, inputType.value])

  // type='string'
  // set the default value for a string input, once
  useEffect(() => {
    if (inputType.value === 'string') {
      defaultValue.value = { value: '', error: '' }
    }
  }, [defaultValue, inputType.value])

  return (
    <Box
      sx={{
        gap: '10px',
        display: 'flex',
        flexDirection: 'column',
        margin: '10px',
      }}
    >
      <Typography variant="h5">
        Config Input Editor for current Command
        <AlertDialog title={`Help: What is a Config Input?`}>
          <Typography>
            Config Inputs are interactive input components that allow the
            end-user to configure the command-to-run with guidance on the
            options available. Config inputs sole purpose is to help gather
            valid values to place into the command. Each Config Input is focused
            on replacing a <CodeTypography>__VALUE__</CodeTypography> within the
            command-to-run.
            <br />
            <br />
            TIP: Config Inputs can also setup more{' '}
            <CodeTypography>__VALUE__</CodeTypography> to replace from another
            Config Input. Put another way, Config Inputs can 'stack' or
            'cascade' their modifications to the command-to-run. A common way
            this is used is first by creating a Checkbox Config Input and then
            creating a String Config Input. The checkbox will allow the end-user
            to disable or enable an entire flag for the command-to-run while the
            string input will allow for validation of the input values.
          </Typography>
        </AlertDialog>
      </Typography>

      <Box display="flex">
        <TextField
          id="config-label"
          multiline
          fullWidth
          label="Short name for this config input"
          value={cmdLabel.value}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            cmdLabel.value = event.target.value
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Help: Short name for this config input`}>
                  <Typography>
                    This is a label or short name shown for this given input.
                    This will help the user understand what value they are
                    entering.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />
        <HelpTextEditor
          helpText={helpText}
          HelpEditingContextComponent={
            <>
              Help for: <CodeTypography>{cmdLabel.value}</CodeTypography>{' '}
              <CodeTypography>{replace.value.value}</CodeTypography>
            </>
          }
        />
      </Box>

      <TextField
        id="config-replace"
        fullWidth
        label="Replacement Value in Command (typically includes __VALUE__)"
        value={replace.value.value}
        error={replace.value.error !== ''}
        helperText={replace.value.error}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          // enforce that replace values need to be unique
          const tmp = event.target.value
          const f = configs.value.filter((cfg) => {
            return cfg.replace === tmp
          })

          const globalF = globalReplacements.filter(
            (grepl) => grepl.replace.toLowerCase() === tmp.toLowerCase()
          )

          const globalSpecialF = globalSpecialReplacements.filter(
            (grepl) => grepl.replace.toLowerCase() === tmp.toLowerCase()
          )

          if (f.length > 0 && editConfig.value?.replace !== tmp) {
            replace.value = { value: tmp, error: 'Uniqueness is required' }
          } else if (globalF.length > 0) {
            replace.value = {
              value: tmp,
              error: 'Cannot be a Global Replacement Value!',
            }
          } else if (globalSpecialF.length > 0) {
            replace.value = {
              value: tmp,
              error: 'Cannot be a Special Replacement Value!',
            }
          } else {
            replace.value = { value: tmp, error: '' }
          }
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Replace Value in Command`}>
                <Typography>
                  The variable name aka value to replace within the command
                  string. Uniqueness is enforced to reduce the chances of odd
                  user experiences.
                  <br />
                  <br />
                  Typical format is{' '}
                  <CodeTypography>__VALUE_NAME__</CodeTypography> (double
                  underscore, capital-case variable name with underscores for
                  separators ending with a double underscore) for each value to
                  replace. However this value can be any string. This would
                  replace the
                  <CodeTypography>__VALUE_NAME__</CodeTypography> within the
                  command with the given input type data, eg '10' for a number
                  input.
                  <br />
                  <br />
                  TIP: Pairing a Checkbox with another input can allow for
                  enabling or disabling an entire command flag.
                  <br />
                  <br />
                  Error Message Additional info:
                  <br />
                  <br />
                  <CodeTypography>Uniqueness is required</CodeTypography> means
                  that another Config in this command already has this
                  replacement value set. Creating two config inputs which set
                  the same value is often a bad idea.
                  <br />
                  <br />
                  <CodeTypography>
                    Cannot be a Global Replacement Value!
                  </CodeTypography>{' '}
                  means that a Global replacement value matches this replacement
                  value. This is not allowed. Consider a naming convention which
                  might be more specific to your command.
                  <br />
                  <br />
                  <CodeTypography>
                    Cannot be a Special Replacement Value!
                  </CodeTypography>{' '}
                  means that a Special global replacement value matches this
                  replacement value. This is not allowed. Consider a naming
                  convention which might be more specific to your command.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      {inputType.value === 'number' && (
        <NumberInput
          defaultValue={minNum.value}
          props={{
            fullWidth: false,
            label: `Default Integer Value`,
            InputProps: {
              inputProps: { min: minNum.value, max: maxNum.value },

              startAdornment: (
                <InputAdornment position="start">
                  <AlertDialog
                    title={`Default Integer Value for this Replacement Value`}
                  >
                    <Typography>
                      The Attacker Port is a generic port number that can easily
                      be assigned within a command. More commonly, a command
                      will define a custom port input so other commands aren't
                      polluted with the wrong port info. The Attacker Port value
                      allows for the use-case when a command needs a port and it
                      can be associated with a lot of other commands.
                      <br />
                      <br />
                      TIP: <CodeTypography>
                        Left Mouse click
                      </CodeTypography>{' '}
                      into the text field and{' '}
                      <CodeTypography>Mouse Wheel Scroll</CodeTypography> to
                      quickly change the value of the Port
                    </Typography>
                  </AlertDialog>
                </InputAdornment>
              ),
            },
            value: defaultValue.value.value,
          }}
          numberChangeEvent={(tmp) => {
            if (tmp < minNum.value || tmp > maxNum.value) {
              defaultValue.value = {
                value: tmp,
                error:
                  'Must be within the range of the Min and Max Value Allowed',
              }
            } else {
              defaultValue.value = {
                value: tmp,
                error: '',
              }
            }
          }}
        />
      )}

      {/* enabled for:
          1. string input
          2. number input
          3. when the Custom Input checkbox is checked
       */}
      {(inputType.value === 'string' ||
        // inputType.value === 'number' ||
        customInput.value === true) && (
        <TextField
          id="config-defaultValue-string-customInput"
          fullWidth
          label="Default Value for this Replacement Value"
          value={defaultValue.value.value}
          error={defaultValue.value.error !== ''}
          helperText={defaultValue.value.error}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            if (inputType.value === 'number') {
              const tmp = parseInt(event.target.value)
              if (isNaN(tmp)) {
                defaultValue.value = {
                  value: event.target.value,
                  error: 'Positive or Negative Integer expected',
                }
              } else {
                if (tmp < minNum.value || tmp > maxNum.value) {
                  defaultValue.value = {
                    value: tmp,
                    error:
                      'Must be within the range of the Min and Max Value Allowed',
                  }
                } else {
                  defaultValue.value = {
                    value: tmp,
                    error: '',
                  }
                }
              }
            } else if (inputType.value === 'string') {
              // TODO: does this need to be validated against the regex if provided?

              if (
                event.target.value.indexOf(replace.value.value) > -1 &&
                replace.value.value !== ''
              ) {
                defaultValue.value = {
                  value: event.target.value,
                  error:
                    'Circular reference detected, contains the Replacement Value',
                }
              } else {
                defaultValue.value = { value: event.target.value, error: '' }
              }
            } else if (inputType.value === 'select') {
              defaultValue.value = { value: event.target.value, error: '' }
            }
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Help: Default Value`}>
                  <Typography>
                    The Default Value to start this Command Config input with.
                    This is either a string or a number depending on the Config
                    Input type.
                    <br />
                    <br /> For a <CodeTypography>string</CodeTypography> input
                    type, this is commonly set to blank (all input cleared).
                    <br />
                    <br /> For a <CodeTypography>number</CodeTypography> input
                    type, this is commonly the minimum or a sane value between
                    the min and max.
                    <br />
                    <br />
                    For a <CodeTypography>select</CodeTypography> input type
                    with the <CodeTypography>custom text input</CodeTypography>{' '}
                    option selected, this can be any text value.
                    <br />
                    <br />
                    TIP: As a <CodeTypography>string</CodeTypography> or{' '}
                    <CodeTypography>select</CodeTypography> input type, this
                    value can include another
                    <CodeTypography>__VALUE__</CodeTypography> variable to
                    replace via another Command Config input.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />
      )}

      <Box sx={{ display: 'flex' }}>
        <AlertDialog title={`Help: Command Config input types`}>
          <Typography>
            Command Configs can have various input types offered to the user.
            Each has it's own UI elements associated. Each has a common use-case
            for the user as well.
            <br />
            <br />
            <CodeTypography>string</CodeTypography> input type allows the end
            user to be given a text input to type into. The user can even
            include <CodeTypography>__VALUE__</CodeTypography> named values to
            have replaced in the command-to-run. A validation regex can be
            configured to reject invalid input, however this is optional as the
            default is to accept all input.
            <br />
            <br />
            <CodeTypography>number</CodeTypography> input type allows for the
            end user to choose a number, within a valid min to max range, and
            have this number inserted into the command-to-run. This reduces the
            chance for typos as well as helps manage things like port numbers a
            little easier.
            <br />
            <br />
            <CodeTypography>checkbox</CodeTypography> input type allows for the
            end user to make a binary decision, eg enable a flag for a command
            or remove it entirely. Checkboxes often have replacement values that
            include additional <CodeTypography>__VALUE__</CodeTypography>{' '}
            variables, and then the command is configured with other inputs to
            fill in all the variables the checkbox inserted. Eg, a checkbox
            turns on a flag which requires both a username and password for
            authentication. For the best user experience they would also be
            given String inputs, one for username and one for the password
            values.
            <br />
            <br />
            <CodeTypography>select</CodeTypography> input type allows for the
            end user to be given options to choose from, or potentially type in
            their own values (if custom input is enabled). This type of input is
            best to help guide a user to the only available options or give them
            the freedom to type in a custom option.
            <br />
            <br />
            <CodeTypography>radio</CodeTypography> input type allows for the end
            user to choose one and only one option from multiple options. Think
            of it like a multiple-choice answer to a question. This type of
            input is best used when a set of flags can be enabled, but only one
            can be enabled at a time. Eg, a Radio input is configured with
            options for adding a password flag to the command or adding a
            pass-the-hash flag to the command. Radio input type is like an Array
            of Checkbox inputs. When an Radio option is selected by the
            end-user, the replacement value is inserted into the command-to-run.
            This means that each Radio option has an replacement value to insert
            which can include additional values to replace - those sub values
            are paired with additional inputs such as a String input to have the
            end-user build a complete command.
          </Typography>
        </AlertDialog>

        <Autocomplete
          disablePortal
          options={ConfigInputTypes}
          disableClearable
          sx={{ width: 300 }}
          renderInput={(params) => (
            <TextField {...params} label={'Command Config input type'} />
          )}
          value={inputType.value}
          onChange={(_event: React.SyntheticEvent, newValue: string | null) => {
            if (newValue === null) {
              // default if somehow they select nothing
              inputType.value = 'string'
              return
            }
            inputType.value = newValue
          }}
        />
      </Box>

      {inputType.value === 'checkbox' && (
        <>
          <Box sx={{ display: 'flex' }}>
            <AlertDialog title="Help: Default Checkbox State">
              <Typography>
                The default checkbox state determines if the checkbox by default
                is checked or not. This means that when the user first selects
                this command, is the checkbox automatically enabled (checked) or
                unchecked. If checked, this means the flag this checkbox enables
                is on by default.
              </Typography>
            </AlertDialog>
            <FormGroup>
              <FormControlLabel
                sx={{ userSelect: 'none' }}
                control={
                  <Checkbox
                    inputProps={{ 'aria-label': 'Default Checkbox state' }}
                    checked={!!defaultValue.value.value}
                    onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                      defaultValue.value = {
                        value: event.target.checked,
                        error: '',
                      }
                    }}
                  />
                }
                label={'Default Checkbox state'}
              />
            </FormGroup>
          </Box>
        </>
      )}

      {/* only display the editor for the given input type */}
      {inputType.value === 'string' && (
        <StringConfigToolEditor
          validationRegex={validationRegex}
          validationHelp={validationHelp}
        />
      )}
      {inputType.value === 'number' && (
        <NumberConfigToolEditor minNum={minNum} maxNum={maxNum} />
      )}
      {inputType.value === 'checkbox' && (
        <CheckboxConfigToolEditor replaceValue={replaceValue} />
      )}
      {inputType.value === 'select' && (
        <>
          <SelectConfigToolEditor
            customInput={customInput}
            optionsList={optionsList}
            defaultValue={defaultValue}
            onDefaultValueChange={(newDefaultValue: string) => {
              defaultValue.value = {
                value: newDefaultValue,
                error: '',
              }
            }}
          />
        </>
      )}

      {inputType.value === 'radio' && (
        <RadioGroupEditor
          listState={radioList}
          uniqueEntries={true}
          defaultValue={defaultValue}
          onDefaultValueChange={(newDefaultValue: RadioGroupProp) => {
            defaultValue.value = {
              value: newDefaultValue.replace,
              error: '',
            }
          }}
        />
      )}

      <SuccessTooltip
        open={addedConfigInputTooltipOpen.value}
        title="Added!"
        placement="left"
      >
        <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
          {editConfig.value === undefined && (
            <Button
              disabled={!allowSave.value}
              color="success"
              variant="contained"
              onClick={() => {
                handleUpdate(false)
              }}
            >
              Add NEW Config Input to Command
            </Button>
          )}

          {editConfig.value !== undefined && (
            <>
              <Button
                disabled={!allowSave.value}
                color="warning"
                variant="contained"
                onClick={() => {
                  handleUpdate(true)
                }}
              >
                Edit Config Input for Command
              </Button>

              <ConfirmDialog
                buttonText="Discard Edits"
                title="Discard any edits to this Config Input?"
                desc="Press Confirm below to stop editing this config input and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
                onConfirm={() => {
                  resetStateToDefaults()
                }}
              />
            </>
          )}

          <ConfirmDialog
            buttonText="RESET Fields"
            title="RESET Config Input Editor fields?"
            desc="Press Confirm below to RESET all of the inputs. ANY edited inputs not yet added to the json will be lost."
            onConfirm={() => {
              resetStateToDefaults()
            }}
          />
        </Box>
      </SuccessTooltip>
    </Box>
  )
})

export default ConfigsEditor
