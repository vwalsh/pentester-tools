import {
  Autocomplete,
  Box,
  Button,
  Checkbox,
  FormControlLabel,
  FormGroup,
  InputAdornment,
  TextField,
  Typography,
} from '@mui/material'
import { useSignal, Signal } from '@preact/signals-react'
import React, { useCallback, useEffect } from 'react'
import AlertDialog from '../../../../components/AlertDialog'
import StringConfigToolEditor from './components/StringConfigToolEditor'
import NumberConfigToolEditor from './components/NumberConfigToolEditor'
import CheckboxConfigToolEditor from './components/CheckboxConfigToolEditor'
import SelectConfigToolEditor from './components/SelectConfigToolEditor'
import {
  CMDConfigProps,
  CheckboxInputProps,
  NumberInputProps,
  StringInputProps,
  SelectInputProps,
} from '../../../Home/components/ConfigInput/ConfigInput'
import SuccessTooltip from '../../../../components/SuccessTooltip'
import ConfirmDialog from '../../../../components/ConfirmDialog'

const ConfigInputTypes = ['string', 'number', 'checkbox', 'select']

interface Props {
  configs: Signal<Array<CMDConfigProps>>
  editConfig: Signal<undefined | CMDConfigProps>
}

const ConfigsEditor = React.memo(({ configs, editConfig }: Props) => {
  const addedConfigInputTooltipOpen = useSignal<boolean>(false)
  const inputType = useSignal<string>('string')
  const defaultValue = useSignal<string | number | boolean>('')
  const cmdLabel = useSignal<string>('')
  const helpText = useSignal<string>('')
  const replace = useSignal({ value: '', error: false })

  // type=='string'
  const validationRegex = useSignal<string>('')
  const validationHelp = useSignal<string>('')

  // type=='number'
  const minNum = useSignal<number>(1)
  const maxNum = useSignal<number>(65535)

  // type=='checkbox'
  const replaceValue = useSignal<string>('')

  // type=='select'
  const customInput = useSignal<boolean>(false)
  const optionsList = useSignal<Array<string>>([])

  const resetStateToDefaults = useCallback(
    (isEditing: boolean = false) => {
      // reset all the values!
      inputType.value = 'string'
      defaultValue.value = ''
      cmdLabel.value = ''
      helpText.value = ''
      replace.value = { value: '', error: false }

      // type=='string'
      validationRegex.value = ''
      validationHelp.value = ''

      // type=='number'
      minNum.value = 1
      maxNum.value = 65535

      // type=='checkbox'
      replaceValue.value = ''

      // type=='select'
      customInput.value = false
      optionsList.value = []

      if (isEditing === false) {
        // reset out of edit mode if not currently starting to edit
        editConfig.value = undefined
      }
    },
    [
      cmdLabel,
      customInput,
      defaultValue,
      editConfig,
      helpText,
      inputType,
      maxNum,
      minNum,
      optionsList,
      replace,
      replaceValue,
      validationHelp,
      validationRegex,
    ]
  )

  const getConfig = useCallback((): CMDConfigProps => {
    let props:
      | NumberInputProps
      | StringInputProps
      | CheckboxInputProps
      | SelectInputProps
      | undefined = undefined

    if (inputType.value === 'string') {
      props = {
        type: 'string',
        label: cmdLabel.value,
      } as StringInputProps
    }
    if (inputType.value === 'number') {
      props = {
        type: 'number',
        label: cmdLabel.value,
        InputProps: {
          inputProps: { min: minNum.value, max: maxNum.value },
        },
      } as NumberInputProps
    }

    if (inputType.value === 'checkbox') {
      props = {
        type: 'checkbox',
        label: cmdLabel.value,
        replaceValue: replaceValue.value,
      } as CheckboxInputProps
    }

    if (inputType.value === 'select') {
      props = {
        type: 'select',
        label: cmdLabel.value,
        customInput: customInput.value,
        options: optionsList.value,
      } as SelectInputProps
    }

    if (props === undefined) {
      throw new Error(
        'config input type not found above, props undefined. stopping'
      )
    }

    return {
      help: helpText.value,
      replace: replace.value.value,
      defaultValue:
        inputType.value === 'checkbox'
          ? !!defaultValue.value
          : defaultValue.value,

      // conditionally add the validationRegex and validationHelp properties if this is a string type input
      ...(inputType.value === 'string' && {
        validationRegex: validationRegex.value,
        validationHelp: validationHelp.value,
      }),

      props: {
        ...props,
      },
    } as CMDConfigProps
  }, [
    cmdLabel.value,
    customInput.value,
    defaultValue.value,
    helpText.value,
    inputType.value,
    maxNum.value,
    minNum.value,
    optionsList.value,
    replace.value.value,
    replaceValue.value,
    validationHelp.value,
    validationRegex.value,
  ])

  const handleUpdate = (isEditing: boolean = false) => {
    const newCfg = getConfig()

    if (isEditing === false) {
      configs.value = [...configs.value, newCfg]
    } else {
      const updated = configs.value.map((cfg) => {
        if (cfg === editConfig.value) {
          return newCfg
        }
        return cfg
      })
      configs.value = updated
    }

    resetStateToDefaults()
    // set tooltip to shown
    addedConfigInputTooltipOpen.value = true
  }

  useEffect(() => {
    if (addedConfigInputTooltipOpen.value === false) {
      return
    }

    const timer1 = setTimeout(() => {
      addedConfigInputTooltipOpen.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  }, [addedConfigInputTooltipOpen, addedConfigInputTooltipOpen.value])

  useEffect(() => {
    if (editConfig.value === undefined) {
      return
    }

    resetStateToDefaults(true)

    inputType.value = editConfig.value.props.type
    defaultValue.value = editConfig.value.defaultValue
    cmdLabel.value = editConfig.value.props.label
    helpText.value = editConfig.value.help
    replace.value = { value: editConfig.value.replace, error: false }

    // type=='string'
    validationRegex.value =
      editConfig.value.validationRegex === undefined
        ? ''
        : editConfig.value.validationRegex
    validationHelp.value =
      editConfig.value.validationHelp === undefined
        ? ''
        : editConfig.value.validationHelp

    // type=='number'
    if (editConfig.value.props.type === 'number') {
      const iprops = editConfig.value.props?.InputProps?.inputProps
      // if (iprops !== undefined) {
      minNum.value = iprops?.min === undefined ? 1 : iprops.min
      maxNum.value = iprops?.max === undefined ? 65535 : iprops.max
      // }
    }

    // type=='checkbox'
    if (editConfig.value.props.type === 'checkbox') {
      replaceValue.value =
        editConfig.value.props?.replaceValue === undefined
          ? ''
          : editConfig.value.props.replaceValue
    }

    if (editConfig.value.props.type === 'select') {
      // type=='select'
      customInput.value =
        editConfig.value.props?.customInput === undefined
          ? false
          : editConfig.value.props.customInput
      optionsList.value =
        editConfig.value.props?.options === undefined
          ? []
          : editConfig.value.props.options
    }
  }, [
    cmdLabel,
    customInput,
    defaultValue,
    editConfig.value,
    helpText,
    inputType,
    maxNum,
    minNum,
    optionsList,
    replace,
    replaceValue,
    resetStateToDefaults,
    validationHelp,
    validationRegex,
  ])

  return (
    <Box
      sx={{
        gap: '10px',
        display: 'flex',
        flexDirection: 'column',
        margin: '10px',
      }}
    >
      <Typography variant="h5">
        Config Input Editor for current Command
        <AlertDialog title={`Help: What is a Config Input?`}>
          <Typography>
            Config Inputs are interactive input components that allow the
            end-user to configure the command-to-run with guidance on the
            options available. Config inputs sole purpose is to help gather
            valid values to place into the command. Each Config Input is focused
            on replacing a __VALUE__ within the command-to-run.
            <br />
            <br />
            TIP: Config Inputs can also setup more __VALUE__ to replace from
            another Config Input. Put another way, Config Inputs can 'stack' or
            'cascade' their modifications to the command-to-run. A common way
            this is used is first by creating a Checkbox Config Input and then
            creating a String Config Input. The checkbox will allow the end-user
            to disable or enable an entire flag for the command-to-run while the
            string input will allow for validation of the input values.
          </Typography>
        </AlertDialog>
      </Typography>

      <TextField
        id="config-label"
        multiline
        fullWidth
        label="Short name for this config input"
        value={cmdLabel.value}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          cmdLabel.value = event.target.value
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Help: Short name for this config input`}>
                <Typography>
                  This is a label or short name shown for this given input. This
                  will help the user understand what value they are entering.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      <TextField
        id="config-help"
        multiline
        fullWidth
        label="Help Text for Command"
        value={helpText.value}
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          helpText.value = event.target.value
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Help Text Entry`}>
                <Typography>
                  The help text for this given input. Be sure to describe what
                  this replacement value does for the command.
                  <br />
                  <br />
                  TIP: Pairing a Checkbox with another input can allow for
                  enabling or disabling an entire command flag.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      <TextField
        id="config-replace"
        fullWidth
        label="Value to Replace in Command"
        value={replace.value.value}
        error={replace.value.error}
        helperText={
          replace.value.error === true ? 'Uniqueness is required' : ''
        }
        onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
          // enforce that replace values need to be unique
          const tmp = event.target.value
          const f = configs.value.filter((cfg) => {
            return cfg.replace === tmp
          })
          if (f.length > 0) {
            replace.value = { value: tmp, error: true }
          } else {
            replace.value = { value: tmp, error: false }
          }
        }}
        InputProps={{
          startAdornment: (
            <InputAdornment position="start">
              <AlertDialog title={`Replace Value in Command`}>
                <Typography>
                  The variable name aka value to replace within the command
                  string. Uniqueness is enforced to reduce the chances of odd
                  user experiences.
                  <br />
                  <br />
                  Typical format is __VALUE_NAME__ (double underscore,
                  capital-case variable name with underscores for separators
                  ending with a double underscore) for each value to replace.
                  However this value can be any string. This would replace the
                  __VALUE_NAME__ within the command with the given input type
                  data, eg '10' for a number input.
                  <br />
                  <br />
                  TIP: Pairing a Checkbox with another input can allow for
                  enabling or disabling an entire command flag.
                </Typography>
              </AlertDialog>
            </InputAdornment>
          ),
        }}
      />

      {/* for all input types EXCEPT checkbox, accept a string or a number */}
      {inputType.value !== 'checkbox' && (
        <TextField
          id="config-defaultValue-number-string"
          fullWidth
          label="Default Value for this Replacement Value"
          value={defaultValue.value}
          onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
            if (inputType.value === 'number') {
              defaultValue.value = parseInt(event.target.value)
            } else {
              defaultValue.value = event.target.value
            }
          }}
          InputProps={{
            startAdornment: (
              <InputAdornment position="start">
                <AlertDialog title={`Default Value`}>
                  <Typography>
                    The Default Value to start this Command Config input with.
                    This is either a string or a number.
                    <br />
                    <br />
                    TIP: As a string type, this value can include another
                    __VALUE__ variable to replace via another Command Config
                    input.
                  </Typography>
                </AlertDialog>
              </InputAdornment>
            ),
          }}
        />
      )}

      <Autocomplete
        disablePortal
        options={ConfigInputTypes}
        disableClearable
        sx={{ width: 300 }}
        renderInput={(params) => (
          <TextField {...params} label={'Command Config input type'} />
        )}
        value={inputType.value}
        onChange={(_event: React.SyntheticEvent, newValue: string | null) => {
          if (newValue === null) {
            // default if somehow they select nothing
            inputType.value = 'string'
            return
          }
          inputType.value = newValue
        }}
      />

      {inputType.value === 'checkbox' && (
        <FormGroup>
          <FormControlLabel
            sx={{ userSelect: 'none' }}
            control={
              <Checkbox
                inputProps={{ 'aria-label': 'Default Checkbox state' }}
                checked={!!defaultValue.value}
                onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                  defaultValue.value = event.target.checked
                }}
              />
            }
            label={'Default Checkbox state'}
          />
        </FormGroup>
      )}

      {/* only display the editor for the given input type */}
      {inputType.value === 'string' && (
        <StringConfigToolEditor
          validationRegex={validationRegex}
          validationHelp={validationHelp}
        />
      )}
      {inputType.value === 'number' && (
        <NumberConfigToolEditor minNum={minNum} maxNum={maxNum} />
      )}
      {inputType.value === 'checkbox' && (
        <CheckboxConfigToolEditor replaceValue={replaceValue} />
      )}
      {inputType.value === 'select' && (
        <SelectConfigToolEditor
          customInput={customInput}
          optionsList={optionsList}
        />
      )}

      <SuccessTooltip
        PopperProps={{
          disablePortal: true,
        }}
        open={addedConfigInputTooltipOpen.value}
        disableFocusListener
        disableHoverListener
        disableTouchListener
        title="Added!"
        placement="left"
      >
        <Box sx={{ display: 'flex', flexDirection: 'row', gap: '10px' }}>
          {editConfig.value === undefined && (
            <Button
              color="success"
              variant="contained"
              onClick={() => {
                handleUpdate(false)
              }}
            >
              Add NEW Config Input to Command
            </Button>
          )}

          {editConfig.value !== undefined && (
            <>
              <Button
                color="warning"
                variant="contained"
                onClick={() => {
                  handleUpdate(true)
                }}
              >
                Edit Config Input for Command
              </Button>

              <ConfirmDialog
                buttonText="Discard Edits"
                title="Discard any edits to this Config Input?"
                desc="Press Confirm below to stop editing this config input and RESET all of the inputs back to defaults. ANY edited inputs not yet added to the json will be lost."
                onConfirm={() => {
                  resetStateToDefaults()
                }}
              />
            </>
          )}

          <ConfirmDialog
            buttonText="RESET Fields"
            title="RESET Config Input Editor fields?"
            desc="Press Confirm below to RESET all of the inputs. ANY edited inputs not yet added to the json will be lost."
            onConfirm={() => {
              resetStateToDefaults()
            }}
          />
        </Box>
      </SuccessTooltip>
    </Box>
  )
})

export default ConfigsEditor
