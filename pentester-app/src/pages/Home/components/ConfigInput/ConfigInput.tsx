import { useSignal } from '@preact/signals-react'
import {
  Autocomplete,
  Checkbox,
  FormControlLabel,
  FormGroup,
  InputAdornment,
  TextField,
} from '@mui/material'
import { useCallback, useContext, useEffect } from 'react'
import React from 'react'
import { AppState } from '../../Home'
import NumberInput from '../../../../components/NumberInput'
import ConfigStringInput from './components/ConfigStringInput'
import CloseIcon from '@mui/icons-material/Close'
import ArrowDropDownIcon from '@mui/icons-material/ArrowDropDown'

// the top level interface defining the /assets/commands.json types+structure
export interface CommandsProps {
  id: string
  keywords: Array<string>
  cmds: Array<CMDProps>
}

export type PlatformOptionsT = 'windows' | 'linux' | 'linux|windows'
export type TerminalOptionsT = 'ps' | 'cmd' | 'sh' | 'bash'

export interface CMDProps {
  // the window number for this command. if a command has the same window number as another command,
  // it will replace the command at that window number.
  win: number

  // the name of this command. if this is specific to a given platform consider including that in the label
  //  so the user can understand if this is intended for windows or linux easily. reduces ambiguity
  label: string

  // TODO: consider adding a DESCRIPTION string so that each command can have a little info icon button to show some basic
  // info about the command and it's purpose

  // what platform is this command intended to run on?
  platform: PlatformOptionsT

  // the type of terminal this command could run in. currently UNUSED
  terminal: Array<TerminalOptionsT>

  // the command with the replacement values in the order necessary to work properly
  cmd: string

  // the help text to display for the command. this is a rich text which has values that are replaced
  // via react components such as ` (backticks) that wrap text are shown as CodeTypography.
  // Newlines turn into page breaks (<br/>) elements
  help: string

  // the various custom inputs for this given command
  config?: Array<CMDConfigProps>

  // can this command be wrapped with spawning options like powershell base64 encoding?
  allowTerminalWrap: boolean

  // can this command be prepended with proxychains like: proxychains -q __CMD__
  allowProxychains: boolean

  // is there any code that is included with this command? it should be base64 encoded or it won't work properly
  code?: Array<{
    filename: string
    data: string
    sha256: string
  }>
}

// this is a custom type interface for a flattened structure of the /assets/commands.json when it's been searched
//   and filtered. this allows for features which need to specify the ID for the given command for uniqueness
// WARNING: this DOES NOT represent the actual /assets/commands.json structure!
export interface CommandWindowsProps extends CMDProps {
  id: string
}

export interface CMDConfigProps {
  // a more detailed help string displayed in when the info button is clicked
  help: string
  // the string to replace within the command typically follows the pattern of '__NAME__'
  replace: string

  // the default value to start with when replacing the above replace string property
  defaultValue: number | string | boolean

  // validation regex to check if the value matches expected patterns
  validationRegex?: string

  // display this text when the user fills in the field incorrectly
  validationHelp?: string

  // props to apply to the various component types
  props:
    | NumberInputProps
    | StringInputProps
    | CheckboxInputProps
    | SelectInputProps
    | RadioInputProps
}

interface DefaultInputProps {
  type: string

  // typical label (eg text string to describe/title something)
  label: string
}

export interface NumberInputProps extends DefaultInputProps {
  type: 'number'

  // allows for a min and max size number to be created
  InputProps: { inputProps: { min: number; max: number } }
}

export interface StringInputProps extends DefaultInputProps {
  type: 'string'
}

export interface CheckboxInputProps extends DefaultInputProps {
  type: 'checkbox'

  //  allows for the value to be replaced as this string when the checkbox is checked/true
  replaceValue: string
}

export interface SelectInputProps extends DefaultInputProps {
  type: 'select'

  // dropdown options array of strings
  options: Array<string>

  // allow the user to enter custom values besides the 'options' array
  customInput: boolean
}

export interface RadioInputProps extends DefaultInputProps {
  type: 'radio'

  // the selectable options for the radio buttons
  // options: Array<RadioGroupProp>

  options: Array<RadioInputOption>
}

interface RadioInputOption {
  replace: string
  label: string
}

// ================================================================
// number input

interface NumberInputCompProps {
  cfg: CMDConfigProps
  // props: NumberInputProps
  defaultValue: string
  // disabled: boolean
  highlightComponent: boolean
}

const NumberConfigInput = React.memo(
  ({
    cfg,
    // props,
    defaultValue,
    // disabled,
    highlightComponent,
  }: NumberInputCompProps) => {
    const { getReplacementValue, setReplacements } = useContext(AppState)
    const val = useSignal<number>(parseInt(defaultValue.toString()))

    useEffect(() => {
      // run this once

      if (cfg.props.type !== 'number') {
        return
      }
      // run once to set the defaultValue or previously set replacements value for this input
      //const f = replacements.value?.[cfg.replace]
      const f = getReplacementValue(cfg.replace)

      if (f !== undefined && typeof f === 'number' && isNaN(f) === false) {
        val.value = f
      } else {
        setReplacements({
          name: cfg.replace,
          value: val.value,
        })
      }
    })

    if (cfg.props.type !== 'number') {
      return <></>
    }
    return (
      <NumberInput
        disabled={!highlightComponent}
        defaultValue={parseInt(defaultValue.toString())}
        props={{
          fullWidth: true,
          ...cfg.props,
          value: val.value,
          disabled: !highlightComponent,
        }}
        numberChangeEvent={(n) => {
          setReplacements({
            name: cfg.replace,
            value: n,
          })
          val.value = n
        }}
      />
    )
  }
)

// ================================================================
// select from a list of options
interface SelectOptionProps {
  cfg: CMDConfigProps
  props: SelectInputProps
  defaultValue: string
  // replacements: Signal<NameValueDict>
  highlightComponent: boolean
}
const SelectOptions = React.memo(
  ({ cfg, props, defaultValue, highlightComponent }: SelectOptionProps) => {
    const { getReplacementValue, setReplacements } = useContext(AppState)
    const optionSelected = useSignal<string>(defaultValue.toString())

    const textHasChanged = useSignal<boolean>(false)
    const editedValue = useSignal<string>('')

    const handleUpdate = useCallback(
      (newValue: string | null) => {
        // return
        if (newValue === null) {
          // the user has cleared the input, if custom input is allowed BLANK IS ALLOWED
          if (props.customInput === true) {
            optionSelected.value = '__BLANK__'
            setReplacements({
              name: cfg.replace,
              value: '__BLANK__',
            })
          } else {
            optionSelected.value = cfg.defaultValue.toString()
            setReplacements({
              name: cfg.replace,
              value: cfg.defaultValue.toString(),
            })
          }
        } else {
          optionSelected.value = newValue
          setReplacements({
            name: cfg.replace,
            value: newValue,
          })
        }

        // reset
        editedValue.value = ''
        textHasChanged.value = false
      },
      [
        cfg.defaultValue,
        optionSelected,
        props.customInput,
        cfg.replace,
        setReplacements,
        editedValue,
        textHasChanged,
      ]
    )

    useEffect(() => {
      // run this once
      if (cfg.props.type !== 'select') {
        return
      }

      // run once to set the defaultValue or previously set replacements value for this input
      const f = getReplacementValue(cfg.replace) //replacements.value?.[cfg.replace]
      if (
        f !== undefined &&
        ((props.customInput === false &&
          props.options.indexOf(f.toString()) > -1) ||
          props.customInput === true)
      ) {
        optionSelected.value = f.toString()
      } else {
        setReplacements({
          name: cfg.replace,
          value: optionSelected.value,
        })
      }
    })

    if (cfg.props.type !== 'select') {
      return <></>
    }

    return (
      <>
        <Autocomplete
          selectOnFocus
          // clearOnEscape
          freeSolo={props.customInput}
          disablePortal
          clearIcon={<CloseIcon color="error" />}
          id={`cfgInput-select-${cfg.replace}`}
          options={
            props.customInput === false
              ? cfg.props.options
              : ['__BLANK__', ...cfg.props.options]
          }
          disabled={!highlightComponent}
          fullWidth
          value={optionSelected.value}
          renderInput={(params) => (
            <TextField
              {...params}
              disabled={!highlightComponent}
              error={textHasChanged.value === true}
              helperText={
                textHasChanged.value === true
                  ? 'press Enter or Tab to accept input'
                  : ''
              }
              color={highlightComponent === true ? 'success' : 'primary'}
              focused
              label={`${cfg.props.label}${
                props.customInput === true ? ' (custom input enabled!)' : ''
              }`}
              onChange={(event) => {
                textHasChanged.value = true
                editedValue.value = event.target.value
              }}
              InputProps={
                props.customInput === true
                  ? {
                      ...params.InputProps,
                      endAdornment: (
                        <>
                          <InputAdornment position="end">
                            <ArrowDropDownIcon
                              color={
                                highlightComponent === true
                                  ? 'primary'
                                  : 'disabled'
                              }
                            />
                          </InputAdornment>
                          {params.InputProps.endAdornment}
                        </>
                      ),
                    }
                  : params.InputProps
              }
            />
          )}
          title={
            highlightComponent === false
              ? 'Input disabled by another option'
              : props.customInput === true
                ? 'Custom Input is enabled, type any value or select an option shown'
                : 'Select only an option shown'
          }
          onBlur={() => {
            // check that the value is allowed
            if (
              props.customInput === false &&
              props.options.indexOf(optionSelected.value) < 0
            ) {
              handleUpdate(null)
            } else if (textHasChanged.value === true) {
              handleUpdate(
                editedValue.value === '' ? '__BLANK__' : editedValue.value
              )
            }
          }}
          onChange={(event: React.SyntheticEvent, newValue: string | null) => {
            if (
              event.type === 'click' &&
              props.customInput === false &&
              newValue === null
            ) {
              // reset to default via the clear button to reduce ui interactions for the user
              handleUpdate(null)
            } else {
              handleUpdate(newValue)
            }
          }}
        />
      </>
    )
  }
)

// ================================================================
// checkbox component
interface CheckboxProps {
  cfg: CMDConfigProps
  props: CheckboxInputProps
  defaultValue: boolean
  highlightComponent: boolean
}
const CheckboxInput = React.memo(
  ({ cfg, props, defaultValue, highlightComponent }: CheckboxProps) => {
    const { replacements, setReplacements } = useContext(AppState)
    const checkboxChecked = useSignal<boolean>(defaultValue)

    useEffect(() => {
      // run this once
      if (props.type !== 'checkbox') {
        return
      }

      // run once to set the defaultValue or previously set replacements value for this input
      const f = replacements.value?.[cfg.replace]

      if (f !== undefined && f === props.replaceValue) {
        checkboxChecked.value = true
      } else {
        setReplacements({
          name: cfg.replace,
          value: checkboxChecked.value === false ? '' : props.replaceValue,
        })
      }
    })

    if (props.type !== 'checkbox') {
      return <></>
    }

    return (
      <FormGroup>
        <FormControlLabel
          title={
            highlightComponent === false
              ? 'Input disabled by another option'
              : ''
          }
          sx={{ userSelect: 'none' }}
          control={
            <Checkbox
              disabled={!highlightComponent}
              inputProps={{ 'aria-label': props.label }}
              checked={checkboxChecked.value}
              onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                checkboxChecked.value = event.target.checked
                let replVal =
                  props.replaceValue === undefined ? '' : props.replaceValue
                if (event.target.checked === false) {
                  replVal = ''
                }
                setReplacements({
                  name: cfg.replace,
                  value: replVal,
                })
              }}
            />
          }
          label={cfg.props.label}
        />
      </FormGroup>
    )
  }
)

interface RadioBtnProps {
  cfg: CMDConfigProps
  props: RadioInputProps
  defaultValue: RadioInputOption | undefined
  highlightComponent: boolean
}
const RadioBtnInput = React.memo(
  ({ cfg, props, defaultValue, highlightComponent }: RadioBtnProps) => {
    const { replacements, setReplacements } = useContext(AppState)

    const optionSelected = useSignal<RadioInputOption>(
      defaultValue === undefined ? props.options[0] : defaultValue
    )

    const handleUpdate = useCallback(
      (newValue: RadioInputOption | null) => {
        if (newValue === null) {
          setReplacements({
            name: cfg.replace,
            value:
              defaultValue === undefined
                ? props.options[0].replace
                : defaultValue.replace,
          })
          optionSelected.value =
            defaultValue === undefined ? props.options[0] : defaultValue
        } else {
          setReplacements({
            name: cfg.replace,
            value: newValue.replace,
          })
          optionSelected.value = newValue
        }
      },
      [
        cfg.replace,
        defaultValue,
        optionSelected,
        props.options,
        setReplacements,
      ]
    )

    useEffect(() => {
      // run once
      if (cfg.props.type !== 'radio') {
        return
      }

      const f = replacements.value?.[cfg.replace]
      const localStoredOpt =
        f === undefined
          ? undefined
          : props.options.find((opt) => {
              return opt.replace === f.toString()
            })

      if (f !== undefined && localStoredOpt !== undefined) {
        // ensure the selected option matches the current replacements state
        optionSelected.value = localStoredOpt
      } else {
        setReplacements({
          name: cfg.replace,
          value:
            defaultValue === undefined
              ? props.options[0].replace
              : defaultValue.replace,
        })
        optionSelected.value =
          defaultValue === undefined ? props.options[0] : defaultValue
      }
    })

    if (cfg.props.type !== 'radio') {
      return <></>
    }

    return (
      <Autocomplete
        selectOnFocus
        disablePortal
        clearIcon={<CloseIcon color="error" />}
        id={`cfgInput-select-${cfg.replace}`}
        options={props.options}
        getOptionLabel={(option) => option.label}
        disabled={!highlightComponent}
        fullWidth
        value={optionSelected.value}
        renderInput={(params) => (
          <TextField
            {...params}
            disabled={!highlightComponent}
            color={highlightComponent === true ? 'success' : 'primary'}
            focused
            label={`${cfg.props.label}`}
          />
        )}
        onChange={(
          _event: React.SyntheticEvent,
          newValue: RadioInputOption | null
        ) => {
          handleUpdate(newValue)
        }}
      />
    )
  }
)

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number | boolean
  highlightComponent: boolean
}

const ConfigInput = React.memo(
  ({ cfg, defaultValue, highlightComponent }: ConfigInputProps) => {
    return (
      <>
        {cfg.props.type === 'number' && (
          <NumberConfigInput
            cfg={cfg}
            defaultValue={defaultValue.toString()}
            highlightComponent={highlightComponent}
          />
        )}

        {cfg.props.type === 'string' && (
          <ConfigStringInput
            disabled={!highlightComponent}
            cfg={cfg}
            props={cfg.props as StringInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}

        {cfg.props.type === 'checkbox' && (
          <CheckboxInput
            highlightComponent={highlightComponent}
            cfg={cfg}
            props={cfg.props as CheckboxInputProps}
            defaultValue={
              typeof defaultValue === 'boolean' ? defaultValue : false
            }
          />
        )}

        {cfg.props.type === 'select' && (
          <SelectOptions
            cfg={cfg}
            props={cfg.props as SelectInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
            highlightComponent={highlightComponent}
          />
        )}

        {cfg.props.type === 'radio' && (
          <RadioBtnInput
            highlightComponent={highlightComponent}
            cfg={cfg}
            props={cfg.props as RadioInputProps}
            defaultValue={cfg.props.options.find(
              (opt) => opt.replace === defaultValue
            )}
          />
        )}
      </>
    )
  }
)

export default ConfigInput
