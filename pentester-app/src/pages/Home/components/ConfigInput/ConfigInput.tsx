import { Signal, useSignal } from '@preact/signals-react'
import {
  Autocomplete,
  Checkbox,
  FormControlLabel,
  FormGroup,
  TextField,
} from '@mui/material'
import { useContext, useEffect } from 'react'

import React from 'react'
import { AppState } from '../../Home'
import NumberInput from '../../../../components/NumberInput'
import { NameValueDict } from '../../../../signals/signals'

export interface CMDProps {
  // the window number for this command. if a command has the same window number as another command,
  // it will replace the command at that window number.
  win: number

  // the name of this command. if this is specific to a given platform consider including that in the label
  //  so the user can understand if this is intended for windows or linux easily. reduces ambiguity
  label: string

  // TODO: consider adding a DESCRIPTION string so that each command can have a little info icon button to show some basic
  // info about the command and it's purpose

  // what platform is this command intended to run on?
  platform: 'windows' | 'linux' | 'linux|windows'

  // the type of terminal this command could run in. currently UNUSED
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>

  // the command with the replacement values in the order necessary to work properly
  cmd: string

  // the various custom inputs for this given command
  config?: Array<CMDConfigProps>

  // can this command be wrapped with spawning options like powershell base64 encoding?
  allowTerminalWrap: boolean

  // is there any code that is included with this command? it should be base64 encoded or it won't work properly
  code?: Array<{
    filename: string
    data: string
  }>
}

export interface CMDConfigProps {
  // a more detailed help string displayed in when the info button is clicked
  help: string
  // the string to replace within the command typically follows the pattern of '__NAME__'
  replace: string

  // the default value to start with when replacing the above replace string property
  defaultValue: number | string | boolean

  // validation regex to check if the value matches expected patterns
  validationRegex?: string

  // display this text when the user fills in the field incorrectly
  validationHelp?: string

  // props to apply to the various component types
  props:
    | NumberInputProps
    | StringInputProps
    | CheckboxInputProps
    | SelectInputProps
}

interface DefaultInputProps {
  type: string

  // typical label (eg text string to describe/title something)
  label: string
}

export interface NumberInputProps extends DefaultInputProps {
  type: 'number'

  // allows for a min and max size number to be created
  InputProps: { inputProps: { min: number; max: number } }
}

export interface StringInputProps extends DefaultInputProps {
  type: 'string'
}

export interface CheckboxInputProps extends DefaultInputProps {
  type: 'checkbox'

  //  allows for the value to be replaced as this string when the checkbox is checked/true
  replaceValue: string
}

export interface SelectInputProps extends DefaultInputProps {
  type: 'select'

  // dropdown options array of strings
  options: Array<string>

  // allow the user to enter custom values besides the 'options' array
  customInput: boolean
}

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number | boolean
  replacements: Signal<NameValueDict>
}

const ConfigInput = React.memo(
  ({ cfg, defaultValue, replacements }: ConfigInputProps) => {
    const { setReplacements } = useContext(AppState)

    // ================================================================
    // string/text input

    interface StringInputCompProps {
      cfg: CMDConfigProps
      props: StringInputProps
      defaultValue: string
    }
    const StringInput = React.memo(
      ({ cfg, props, defaultValue }: StringInputCompProps) => {
        const val = useSignal<string>(defaultValue)
        const validationError = useSignal<boolean>(false)

        useEffect(() => {
          // run this once

          if (cfg.props.type !== 'string') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]

          if (f !== undefined && typeof f === 'string') {
            val.value = f
          } else {
            setReplacements({
              name: cfg.replace,
              value: defaultValue,
            })
          }
        })

        if (cfg.props.type !== 'string') {
          return <></>
        }
        return (
          <TextField
            fullWidth
            {...props}
            value={val}
            error={validationError.value}
            helperText={
              validationError.value === true ? cfg.validationHelp : ''
            }
            onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
              // validate if the validationRegex exists
              if (
                cfg.validationRegex !== undefined &&
                cfg.validationRegex !== ''
              ) {
                const re = new RegExp(cfg.validationRegex)

                validationError.value = !re.test(event.target.value)
              }

              val.value = event.target.value
              setReplacements({
                name: cfg.replace,
                value: event.target.value,
              })
            }}
          />
        )
      }
    )

    // ================================================================
    // number input
    const NumberConfigInput = React.memo(() => {
      const val = useSignal<number>(parseInt(defaultValue.toString()))
      // const error = useSignal<boolean>(false)

      useEffect(() => {
        // run this once

        if (cfg.props.type !== 'number') {
          return
        }
        // run once to set the defaultValue or previously set replacements value for this input
        const f = replacements.value?.[cfg.replace]

        if (f !== undefined && typeof f === 'number' && isNaN(f) === false) {
          val.value = f
        }

        setReplacements({
          name: cfg.replace,
          value: val.value,
        })
      }, [val])

      if (cfg.props.type !== 'number') {
        return <></>
      }
      return (
        <NumberInput
          props={{
            fullWidth: true,
            ...cfg.props,
            value: val.value,
          }}
          numberChangeEvent={(n) => {
            setReplacements({
              name: cfg.replace,
              value: n,
            })
            val.value = n
          }}
        />
      )
    })

    // ================================================================
    // checkbox component
    interface CheckboxProps {
      cfg: CMDConfigProps
      props: CheckboxInputProps
      defaultValue: boolean
    }
    const CheckboxInput = React.memo(
      ({ cfg, props, defaultValue }: CheckboxProps) => {
        const checkboxChecked = useSignal<boolean>(defaultValue)

        useEffect(() => {
          // run this once
          if (props.type !== 'checkbox') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]

          if (f !== undefined && f === props.replaceValue) {
            checkboxChecked.value = true
          } else {
            setReplacements({
              name: cfg.replace,
              value: checkboxChecked.value === false ? '' : props.replaceValue,
            })
          }
        })

        if (props.type !== 'checkbox') {
          return <></>
        }

        return (
          <FormGroup>
            <FormControlLabel
              sx={{ userSelect: 'none' }}
              control={
                <Checkbox
                  inputProps={{ 'aria-label': props.label }}
                  checked={checkboxChecked.value}
                  onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                    checkboxChecked.value = event.target.checked
                    let replVal =
                      props.replaceValue === undefined ? '' : props.replaceValue
                    if (event.target.checked === false) {
                      replVal = ''
                    }
                    setReplacements({
                      name: cfg.replace,
                      value: replVal,
                    })
                  }}
                />
              }
              label={cfg.props.label}
            />
          </FormGroup>
        )
      }
    )

    // ================================================================
    // select from a list of options
    const SelectOptions = React.memo(() => {
      const optionSelected = useSignal<string>(defaultValue.toString())

      useEffect(() => {
        // run this once

        if (cfg.props.type !== 'select') {
          return
        }

        // run once to set the defaultValue or previously set replacements value for this input
        const f = replacements.value?.[cfg.replace]

        if (f !== undefined && cfg.props.options.indexOf(f.toString()) > -1) {
          optionSelected.value = f.toString()
        } else {
          setReplacements({
            name: cfg.replace,
            value: optionSelected.value,
          })
        }
      }, [optionSelected])

      if (cfg.props.type !== 'select') {
        return <></>
      }

      return (
        <>
          <Autocomplete
            freeSolo={cfg.props.customInput}
            disablePortal
            id={`omni-${cfg.replace}`}
            options={cfg.props.options}
            sx={{ width: 300 }}
            renderInput={(params) => (
              <TextField {...params} label={cfg.props.label} />
            )}
            value={optionSelected.value}
            onChange={(
              _event: React.SyntheticEvent,
              newValue: string | null
            ) => {
              if (newValue === null) {
                optionSelected.value = ''
                return
              }
              optionSelected.value = newValue
              setReplacements({
                name: cfg.replace,
                value: newValue,
              })
            }}
          />
        </>
      )
    })

    return (
      <>
        <NumberConfigInput />
        <StringInput
          cfg={cfg}
          props={cfg.props as StringInputProps}
          defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
        />
        <CheckboxInput
          cfg={cfg}
          props={cfg.props as CheckboxInputProps}
          defaultValue={
            typeof defaultValue === 'boolean' ? defaultValue : false
          }
        />
        <SelectOptions />
      </>
    )
  }
)

export default ConfigInput
