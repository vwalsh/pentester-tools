import { Signal, useSignal } from '@preact/signals-react'
import {
  Autocomplete,
  Checkbox,
  FormControl,
  FormControlLabel,
  FormGroup,
  FormLabel,
  Radio,
  RadioGroup,
  TextField,
} from '@mui/material'
import { useContext, useEffect } from 'react'
import React from 'react'
import { AppState } from '../../Home'
import NumberInput from '../../../../components/NumberInput'
import { NameValueDict } from '../../../../signals/signals'
import ConfigStringInput from './components/ConfigStringInput'
import { RadioGroupProp } from '../../../NewCommandBuilder/components/ConfigsEditor/components/RadioGroupEditor/RadioGroupEditor'

// the top level interface defining the /assets/commands.json types+structure
export interface CommandsProps {
  id: string
  keywords: Array<string>
  cmds: Array<CMDProps>
}

export interface CMDProps {
  // the window number for this command. if a command has the same window number as another command,
  // it will replace the command at that window number.
  win: number

  // the name of this command. if this is specific to a given platform consider including that in the label
  //  so the user can understand if this is intended for windows or linux easily. reduces ambiguity
  label: string

  // TODO: consider adding a DESCRIPTION string so that each command can have a little info icon button to show some basic
  // info about the command and it's purpose

  // what platform is this command intended to run on?
  platform: 'windows' | 'linux' | 'linux|windows'

  // the type of terminal this command could run in. currently UNUSED
  terminal: Array<'ps' | 'cmd' | 'sh' | 'bash'>

  // the command with the replacement values in the order necessary to work properly
  cmd: string

  // the various custom inputs for this given command
  config?: Array<CMDConfigProps>

  // can this command be wrapped with spawning options like powershell base64 encoding?
  allowTerminalWrap: boolean

  // can this command be prepended with proxychains like: proxychains -q __CMD__
  allowProxychains: boolean

  // is there any code that is included with this command? it should be base64 encoded or it won't work properly
  code?: Array<{
    filename: string
    data: string
    sha256: string
  }>
}

// this is a custom type interface for a flattened structure of the /assets/commands.json when it's been searched
//   and filtered. this allows for features which need to specify the ID for the given command for uniqueness
// WARNING: this DOES NOT represent the actual /assets/commands.json structure!
export interface CommandWindowsProps extends CMDProps {
  id: string
}

export interface CMDConfigProps {
  // a more detailed help string displayed in when the info button is clicked
  help: string
  // the string to replace within the command typically follows the pattern of '__NAME__'
  replace: string

  // the default value to start with when replacing the above replace string property
  defaultValue: number | string | boolean

  // validation regex to check if the value matches expected patterns
  validationRegex?: string

  // display this text when the user fills in the field incorrectly
  validationHelp?: string

  // props to apply to the various component types
  props:
    | NumberInputProps
    | StringInputProps
    | CheckboxInputProps
    | SelectInputProps
    | RadioInputProps
}

interface DefaultInputProps {
  type: string

  // typical label (eg text string to describe/title something)
  label: string
}

export interface NumberInputProps extends DefaultInputProps {
  type: 'number'

  // allows for a min and max size number to be created
  InputProps: { inputProps: { min: number; max: number } }
}

export interface StringInputProps extends DefaultInputProps {
  type: 'string'
}

export interface CheckboxInputProps extends DefaultInputProps {
  type: 'checkbox'

  //  allows for the value to be replaced as this string when the checkbox is checked/true
  replaceValue: string
}

export interface SelectInputProps extends DefaultInputProps {
  type: 'select'

  // dropdown options array of strings
  options: Array<string>

  // allow the user to enter custom values besides the 'options' array
  customInput: boolean
}

export interface RadioInputProps extends DefaultInputProps {
  type: 'radio'

  // the selectable options for the radio buttons
  options: Array<RadioGroupProp>
}

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number | boolean
  replacements: Signal<NameValueDict>
}

const ConfigInput = React.memo(
  ({ cfg, defaultValue, replacements }: ConfigInputProps) => {
    const { setReplacements } = useContext(AppState)

    // ================================================================
    // number input
    const NumberConfigInput = React.memo(() => {
      const val = useSignal<number>(parseInt(defaultValue.toString()))

      useEffect(() => {
        // run this once

        if (cfg.props.type !== 'number') {
          return
        }
        // run once to set the defaultValue or previously set replacements value for this input
        const f = replacements.value?.[cfg.replace]

        if (f !== undefined && typeof f === 'number' && isNaN(f) === false) {
          val.value = f
        }

        setReplacements({
          name: cfg.replace,
          value: val.value,
        })
      }, [val])

      if (cfg.props.type !== 'number') {
        return <></>
      }
      return (
        <NumberInput
          props={{
            fullWidth: true,
            ...cfg.props,
            value: val.value,
          }}
          numberChangeEvent={(n) => {
            setReplacements({
              name: cfg.replace,
              value: n,
            })
            val.value = n
          }}
        />
      )
    })

    // ================================================================
    // checkbox component
    interface CheckboxProps {
      cfg: CMDConfigProps
      props: CheckboxInputProps
      defaultValue: boolean
    }
    const CheckboxInput = React.memo(
      ({ cfg, props, defaultValue }: CheckboxProps) => {
        const checkboxChecked = useSignal<boolean>(defaultValue)

        useEffect(() => {
          // run this once
          if (props.type !== 'checkbox') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]

          if (f !== undefined && f === props.replaceValue) {
            checkboxChecked.value = true
          } else {
            setReplacements({
              name: cfg.replace,
              value: checkboxChecked.value === false ? '' : props.replaceValue,
            })
          }
        })

        if (props.type !== 'checkbox') {
          return <></>
        }

        return (
          <FormGroup>
            <FormControlLabel
              sx={{ userSelect: 'none' }}
              control={
                <Checkbox
                  inputProps={{ 'aria-label': props.label }}
                  checked={checkboxChecked.value}
                  onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                    checkboxChecked.value = event.target.checked
                    let replVal =
                      props.replaceValue === undefined ? '' : props.replaceValue
                    if (event.target.checked === false) {
                      replVal = ''
                    }
                    setReplacements({
                      name: cfg.replace,
                      value: replVal,
                    })
                  }}
                />
              }
              label={cfg.props.label}
            />
          </FormGroup>
        )
      }
    )

    // ================================================================
    // select from a list of options
    interface SelectOptionProps {
      cfg: CMDConfigProps
      props: SelectInputProps
      defaultValue: string
    }
    const SelectOptions = React.memo(
      ({ cfg, props, defaultValue }: SelectOptionProps) => {
        const optionSelected = useSignal<string>(defaultValue.toString())

        useEffect(() => {
          // run this once

          if (cfg.props.type !== 'select') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]

          if (f !== undefined && props.options.indexOf(f.toString()) > -1) {
            optionSelected.value = f.toString()
          } else {
            setReplacements({
              name: cfg.replace,
              value: optionSelected.value,
            })
          }
        }, [optionSelected, cfg.props.type, cfg.replace, props.options])

        if (cfg.props.type !== 'select') {
          return <></>
        }

        return (
          <>
            <Autocomplete
              freeSolo={cfg.props.customInput}
              disablePortal
              id={`cfgInput-select-${cfg.replace}`}
              options={cfg.props.options}
              sx={{ width: 300 }}
              renderInput={(params) => (
                <TextField {...params} label={cfg.props.label} />
              )}
              value={optionSelected.value}
              onChange={(
                _event: React.SyntheticEvent,
                newValue: string | null
              ) => {
                if (newValue === null) {
                  // optionSelected.value = ''
                  // return
                  optionSelected.value = props.options[0]
                  setReplacements({
                    name: cfg.replace,
                    value: props.options[0],
                  })
                } else {
                  optionSelected.value = newValue
                  setReplacements({
                    name: cfg.replace,
                    value: newValue,
                  })
                }
              }}
            />
          </>
        )
      }
    )

    interface RadioBtnProps {
      cfg: CMDConfigProps
      props: RadioInputProps
      defaultValue: string
    }
    const RadioBtnInput = React.memo(
      ({ cfg, props, defaultValue }: RadioBtnProps) => {
        const RadioOptions = React.memo(() => {
          if (props.options === undefined || props.options.length < 1) {
            return <></>
          }

          return props.options.map((opt) => {
            return (
              <FormControlLabel
                key={`radio-option-${opt.label}-${opt.replace}`}
                value={opt.replace}
                control={<Radio />}
                label={opt.label}
                // checked={cfg.defaultValue === opt.replace}
              />
            )
          })
        })

        useEffect(() => {
          // run once
          if (cfg.props.type !== 'radio') {
            return
          }

          // set the replacement value for this radio option
          setReplacements({
            name: cfg.replace,
            value: defaultValue,
          })
        }, [cfg.props.type, cfg.replace, defaultValue])

        if (cfg.props.type !== 'radio') {
          return <></>
        }

        return (
          <FormControl>
            <FormLabel id={`radio-${cfg.replace}`}>{props.label}</FormLabel>
            <RadioGroup
              row
              aria-labelledby={`radio-${cfg.replace}`}
              name={`radio-${cfg.replace}-group`}
              defaultValue={defaultValue}
              onChange={(
                _event: React.ChangeEvent<HTMLInputElement>,
                value: string
              ) => {
                const tmp = props.options.filter(
                  (opt) => opt.replace === value
                )[0]
                if (tmp !== undefined) {
                  setReplacements({
                    name: cfg.replace,
                    value: tmp.replace,
                  })
                }
              }}
            >
              <RadioOptions />
            </RadioGroup>
          </FormControl>
        )
      }
    )

    return (
      <>
        {cfg.props.type === 'number' && <NumberConfigInput />}

        {cfg.props.type === 'string' && (
          <ConfigStringInput
            cfg={cfg}
            props={cfg.props as StringInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}

        {cfg.props.type === 'checkbox' && (
          <CheckboxInput
            cfg={cfg}
            props={cfg.props as CheckboxInputProps}
            defaultValue={
              typeof defaultValue === 'boolean' ? defaultValue : false
            }
          />
        )}

        {cfg.props.type === 'select' && (
          <SelectOptions
            cfg={cfg}
            props={cfg.props as SelectInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}

        {cfg.props.type === 'radio' && (
          <RadioBtnInput
            cfg={cfg}
            props={cfg.props as RadioInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}
      </>
    )
  }
)

export default ConfigInput
