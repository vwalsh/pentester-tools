import { Signal, useSignal } from '@preact/signals-react'
import {
  Autocomplete,
  Checkbox,
  FormControl,
  FormControlLabel,
  FormGroup,
  FormLabel,
  Radio,
  RadioGroup,
  TextField,
} from '@mui/material'
import { useContext, useEffect } from 'react'
import React from 'react'
import { AppState } from '../../Home'
import NumberInput from '../../../../components/NumberInput'
import { NameValueDict } from '../../../../signals/signals'
import ConfigStringInput from './components/ConfigStringInput'
import { RadioGroupProp } from '../../../NewCommandBuilder/components/ConfigsEditor/components/RadioGroupEditor/RadioGroupEditor'
import CloseIcon from '@mui/icons-material/Close'

// the top level interface defining the /assets/commands.json types+structure
export interface CommandsProps {
  id: string
  keywords: Array<string>
  cmds: Array<CMDProps>
}

export type PlatformOptionsT = 'windows' | 'linux' | 'linux|windows'
export type TerminalOptionsT = 'ps' | 'cmd' | 'sh' | 'bash'

export interface CMDProps {
  // the window number for this command. if a command has the same window number as another command,
  // it will replace the command at that window number.
  win: number

  // the name of this command. if this is specific to a given platform consider including that in the label
  //  so the user can understand if this is intended for windows or linux easily. reduces ambiguity
  label: string

  // TODO: consider adding a DESCRIPTION string so that each command can have a little info icon button to show some basic
  // info about the command and it's purpose

  // what platform is this command intended to run on?
  platform: PlatformOptionsT

  // the type of terminal this command could run in. currently UNUSED
  terminal: Array<TerminalOptionsT>

  // the command with the replacement values in the order necessary to work properly
  cmd: string

  // the help text to display for the command. this is a rich text which has values that are replaced
  // via react components such as ` (backticks) that wrap text are shown as CodeTypography.
  // Newlines turn into page breaks (<br/>) elements
  help: string

  // the various custom inputs for this given command
  config?: Array<CMDConfigProps>

  // can this command be wrapped with spawning options like powershell base64 encoding?
  allowTerminalWrap: boolean

  // can this command be prepended with proxychains like: proxychains -q __CMD__
  allowProxychains: boolean

  // is there any code that is included with this command? it should be base64 encoded or it won't work properly
  code?: Array<{
    filename: string
    data: string
    sha256: string
  }>
}

// this is a custom type interface for a flattened structure of the /assets/commands.json when it's been searched
//   and filtered. this allows for features which need to specify the ID for the given command for uniqueness
// WARNING: this DOES NOT represent the actual /assets/commands.json structure!
export interface CommandWindowsProps extends CMDProps {
  id: string
}

export interface CMDConfigProps {
  // a more detailed help string displayed in when the info button is clicked
  help: string
  // the string to replace within the command typically follows the pattern of '__NAME__'
  replace: string

  // the default value to start with when replacing the above replace string property
  defaultValue: number | string | boolean

  // validation regex to check if the value matches expected patterns
  validationRegex?: string

  // display this text when the user fills in the field incorrectly
  validationHelp?: string

  // props to apply to the various component types
  props:
    | NumberInputProps
    | StringInputProps
    | CheckboxInputProps
    | SelectInputProps
    | RadioInputProps
}

interface DefaultInputProps {
  type: string

  // typical label (eg text string to describe/title something)
  label: string
}

export interface NumberInputProps extends DefaultInputProps {
  type: 'number'

  // allows for a min and max size number to be created
  InputProps: { inputProps: { min: number; max: number } }
}

export interface StringInputProps extends DefaultInputProps {
  type: 'string'
}

export interface CheckboxInputProps extends DefaultInputProps {
  type: 'checkbox'

  //  allows for the value to be replaced as this string when the checkbox is checked/true
  replaceValue: string
}

export interface SelectInputProps extends DefaultInputProps {
  type: 'select'

  // dropdown options array of strings
  options: Array<string>

  // allow the user to enter custom values besides the 'options' array
  customInput: boolean
}

export interface RadioInputProps extends DefaultInputProps {
  type: 'radio'

  // the selectable options for the radio buttons
  options: Array<RadioGroupProp>
}

interface ConfigInputProps {
  cfg: CMDConfigProps
  defaultValue: string | number | boolean
  replacements: Signal<NameValueDict>
  highlightComponent: boolean
}

const ConfigInput = React.memo(
  ({
    cfg,
    defaultValue,
    replacements,
    highlightComponent,
  }: ConfigInputProps) => {
    const { setReplacements } = useContext(AppState)

    // ================================================================
    // number input
    const NumberConfigInput = React.memo(() => {
      const val = useSignal<number>(parseInt(defaultValue.toString()))

      useEffect(() => {
        // run this once

        if (cfg.props.type !== 'number') {
          return
        }
        // run once to set the defaultValue or previously set replacements value for this input
        const f = replacements.value?.[cfg.replace]

        if (f !== undefined && typeof f === 'number' && isNaN(f) === false) {
          val.value = f
        }

        setReplacements({
          name: cfg.replace,
          value: val.value,
        })
      }, [val])

      if (cfg.props.type !== 'number') {
        return <></>
      }
      return (
        <NumberInput
          disabled={!highlightComponent}
          defaultValue={parseInt(defaultValue.toString())}
          props={{
            fullWidth: true,
            ...cfg.props,
            value: val.value,
            disabled: !highlightComponent,
          }}
          numberChangeEvent={(n) => {
            setReplacements({
              name: cfg.replace,
              value: n,
            })
            val.value = n
          }}
        />
      )
    })

    // ================================================================
    // checkbox component
    interface CheckboxProps {
      cfg: CMDConfigProps
      props: CheckboxInputProps
      defaultValue: boolean
    }
    const CheckboxInput = React.memo(
      ({ cfg, props, defaultValue }: CheckboxProps) => {
        const checkboxChecked = useSignal<boolean>(defaultValue)

        useEffect(() => {
          // run this once
          if (props.type !== 'checkbox') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]

          if (f !== undefined && f === props.replaceValue) {
            checkboxChecked.value = true
          } else {
            setReplacements({
              name: cfg.replace,
              value: checkboxChecked.value === false ? '' : props.replaceValue,
            })
          }
        })

        if (props.type !== 'checkbox') {
          return <></>
        }

        return (
          <FormGroup>
            <FormControlLabel
              title={
                highlightComponent === false
                  ? 'Input disabled by another option'
                  : ''
              }
              sx={{ userSelect: 'none' }}
              control={
                <Checkbox
                  disabled={!highlightComponent}
                  inputProps={{ 'aria-label': props.label }}
                  checked={checkboxChecked.value}
                  onChange={(event: React.ChangeEvent<HTMLInputElement>) => {
                    checkboxChecked.value = event.target.checked
                    let replVal =
                      props.replaceValue === undefined ? '' : props.replaceValue
                    if (event.target.checked === false) {
                      replVal = ''
                    }
                    setReplacements({
                      name: cfg.replace,
                      value: replVal,
                    })
                  }}
                />
              }
              label={cfg.props.label}
            />
          </FormGroup>
        )
      }
    )

    // ================================================================
    // select from a list of options
    interface SelectOptionProps {
      cfg: CMDConfigProps
      props: SelectInputProps
      defaultValue: string
    }
    const SelectOptions = React.memo(
      ({ cfg, props, defaultValue }: SelectOptionProps) => {
        const optionSelected = useSignal<string>(defaultValue.toString())

        const handleUpdate = (newValue: string | null) => {
          if (newValue === null) {
            optionSelected.value = props.options[0]
            setReplacements({
              name: cfg.replace,
              value: props.options[0],
            })
          } else {
            optionSelected.value = newValue
            setReplacements({
              name: cfg.replace,
              value: newValue,
            })
          }
        }

        useEffect(() => {
          // run this once

          if (cfg.props.type !== 'select') {
            return
          }

          // run once to set the defaultValue or previously set replacements value for this input
          const f = replacements.value?.[cfg.replace]
          if (f !== undefined && props.options.indexOf(f.toString()) > -1) {
            optionSelected.value = f.toString()
          } else {
            setReplacements({
              name: cfg.replace,
              value: optionSelected.value,
            })
          }
        }, [optionSelected, cfg.props.type, cfg.replace, props.options])

        if (cfg.props.type !== 'select') {
          return <></>
        }

        return (
          <>
            <Autocomplete
              selectOnFocus
              freeSolo={props.customInput}
              disablePortal
              clearIcon={<CloseIcon color="error" />}
              id={`cfgInput-select-${cfg.replace}`}
              options={cfg.props.options}
              disabled={!highlightComponent}
              fullWidth
              renderInput={(params) => (
                <TextField
                  {...params}
                  disabled={!highlightComponent}
                  color={highlightComponent === true ? 'success' : 'primary'}
                  focused
                  label={`${cfg.props.label}${
                    props.customInput === true ? ' (custom input enabled!)' : ''
                  }`}
                  onChange={(event) => {
                    if (props.customInput === true) {
                      handleUpdate(event.target.value)
                    }
                  }}
                />
              )}
              title={
                highlightComponent === false
                  ? 'Input disabled by another option'
                  : props.customInput === true
                    ? 'Custom Input is enabled, type any value or select an option shown'
                    : 'Select only an option shown'
              }
              value={optionSelected.value}
              onBlur={() => {
                // check that the value is allowed
                if (
                  props.customInput === false &&
                  props.options.indexOf(optionSelected.value) < 0
                ) {
                  handleUpdate(null)
                }
              }}
              onChange={(
                event: React.SyntheticEvent,
                newValue: string | null
              ) => {
                if (
                  event.type === 'click' &&
                  props.customInput === false &&
                  newValue === null
                ) {
                  // reset to default via the clear button to reduce ui interactions for the user
                  handleUpdate(null)
                } else {
                  handleUpdate(newValue)
                }
              }}
            />
          </>
        )
      }
    )

    interface RadioBtnProps {
      cfg: CMDConfigProps
      props: RadioInputProps
      defaultValue: string
    }
    const RadioBtnInput = React.memo(
      ({ cfg, props, defaultValue }: RadioBtnProps) => {
        const radioSelected = useSignal<string>(defaultValue.toString())

        const RadioOptions = React.memo(() => {
          if (props.options === undefined || props.options.length < 1) {
            return <></>
          }

          return props.options.map((opt) => {
            return (
              <FormControlLabel
                disabled={!highlightComponent}
                key={`radio-option-${opt.label}-${opt.replace}`}
                value={opt.replace}
                control={<Radio />}
                label={opt.label}
                sx={{ display: 'block', width: '100%' }}
              />
            )
          })
        })

        useEffect(() => {
          // run once
          if (cfg.props.type !== 'radio') {
            return
          }

          const f = replacements.value?.[cfg.replace]

          if (
            f !== undefined &&
            props.options.filter((opt) => opt.replace === f.toString()).length >
              -1
          ) {
            // ensure the radio selected option matches the current replacements state
            radioSelected.value = f.toString()
          } else {
            // set the replacement value for this radio option
            setReplacements({
              name: cfg.replace,
              value: defaultValue,
            })
            radioSelected.value = defaultValue
          }
        }, [
          cfg.props.type,
          cfg.replace,
          defaultValue,
          props.options,
          radioSelected,
        ])

        if (cfg.props.type !== 'radio') {
          return <></>
        }

        return (
          <FormControl>
            <FormLabel id={`radio-${cfg.replace}`}>{props.label}</FormLabel>
            <RadioGroup
              sx={{
                '& .MuiFormControlLabel-root': {
                  display: 'flex !important',
                  borderLeft: `1px solid ${
                    highlightComponent === true ? '#66bb6a' : '#333'
                  }`,
                  borderBottom: `1px solid ${
                    highlightComponent === true ? '#66bb6a' : '#333'
                  }`,
                  borderRadius: '4px',
                  margin: '2px',
                  ...(highlightComponent === false && { color: '#111' }),
                },

                '& .MuiFormControlLabel-label': {
                  // textIndent: '-15px',
                  paddingLeft: '10px',
                },
              }}
              row
              aria-labelledby={`radio-${cfg.replace}`}
              name={`radio-${cfg.replace}-group`}
              value={radioSelected.value}
              onChange={(
                _event: React.ChangeEvent<HTMLInputElement>,
                value: string
              ) => {
                const tmp = props.options.filter(
                  (opt) => opt.replace === value
                )[0]
                if (tmp !== undefined) {
                  radioSelected.value = tmp.replace
                  setReplacements({
                    name: cfg.replace,
                    value: tmp.replace,
                  })
                }
              }}
            >
              <RadioOptions />
            </RadioGroup>
          </FormControl>
        )
      }
    )

    return (
      <>
        {cfg.props.type === 'number' && <NumberConfigInput />}

        {cfg.props.type === 'string' && (
          <ConfigStringInput
            disabled={!highlightComponent}
            cfg={cfg}
            props={cfg.props as StringInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}

        {cfg.props.type === 'checkbox' && (
          <CheckboxInput
            cfg={cfg}
            props={cfg.props as CheckboxInputProps}
            defaultValue={
              typeof defaultValue === 'boolean' ? defaultValue : false
            }
          />
        )}

        {cfg.props.type === 'select' && (
          <SelectOptions
            cfg={cfg}
            props={cfg.props as SelectInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}

        {cfg.props.type === 'radio' && (
          <RadioBtnInput
            cfg={cfg}
            props={cfg.props as RadioInputProps}
            defaultValue={typeof defaultValue === 'string' ? defaultValue : ''}
          />
        )}
      </>
    )
  }
)

export default ConfigInput
