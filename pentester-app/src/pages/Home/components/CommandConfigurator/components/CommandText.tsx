import { Box, Typography } from '@mui/material'

import React, { useCallback, useContext, useMemo } from 'react'
import CopyItem from '../../../../../components/CopyItem'
import { CommandWindowsProps } from '../../ConfigInput/ConfigInput'
import { AppState } from '../../../Home'
import { useComputed, useSignal, useSignalEffect } from '@preact/signals-react'
import SuccessTooltip from '../../../../../components/SuccessTooltip'
import WarningIcon from '@mui/icons-material/Warning'
import AlertDialog from '../../../../../components/AlertDialog'
import CodeTypography from '../../../../../components/CodeTypography'

import Markdown from 'react-markdown'
import remarkGfm from 'remark-gfm'
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'
import { gruvboxDark as syntaxHighlightingStyle } from 'react-syntax-highlighter/dist/esm/styles/prism'

interface CommandTextProps {
  windowNum: number
}

const CommandText = React.memo(({ windowNum }: CommandTextProps) => {
  const {
    ahost,
    aport,
    httpFile,
    replacements,
    terminalWraps,
    proxychainPrepends,
    command_windows,
    vhost,
    vport,
    loot,
  } = useContext(AppState)

  const updateStatus = useSignal<boolean>(false)
  const displayUnreplacedValueWarning = useSignal<boolean>(false)

  const powershellEncodeBase64Command = useCallback((cmd: string): string => {
    const encoder = new TextEncoder()
    const encoded = encoder.encode(cmd)
    let binaryString = ''
    const nullString = String.fromCharCode(0)
    encoded.forEach((byte) => {
      binaryString += String.fromCharCode(byte) + nullString
    })
    return btoa(binaryString)
  }, [])

  const cwin = useComputed((): CommandWindowsProps => {
    return command_windows.value[windowNum]
  })

  const cmdText = useComputed((): string => {
    if (
      ahost.value === undefined ||
      aport.value === undefined ||
      httpFile.value === undefined ||
      cwin.value === undefined ||
      cwin.value.cmd === undefined
    ) {
      return ''
    }

    let tmp = cwin.value.cmd
    let i = 0
    while (i < 2) {
      // to ensure layered/cascaded values get replaced properly, run this code a few times
      tmp = tmp.replaceAll('__ATTACKER_HOST__', ahost.value)
      tmp = tmp.replaceAll('__ATTACKER_PORT__', aport.value.toString())

      tmp = tmp.replaceAll('__TARGET_HOST__', vhost.value)
      tmp = tmp.replaceAll('__TARGET_PORT__', vport.value.toString())

      const httpPath = httpFile.value.split('/')
      const httpFileName = httpPath.pop()
      const httpRootPath = httpPath.join('/')

      tmp = tmp.replaceAll('/__PATH__', httpRootPath)
      tmp = tmp.replaceAll(
        '__FILE__',
        httpFileName !== undefined ? httpFileName : ''
      )

      // replace all of the config set properties
      if (replacements.value !== undefined) {
        Object.keys(replacements.value).forEach(function (key) {
          tmp = tmp.replaceAll(key, replacements.value[key].toString())
        })
      }

      // replace all of the __LOOT_*__ vars being used
      Object.keys(loot.value).forEach(function (key) {
        tmp = tmp.replaceAll(key, loot.value[key].toString())
      })

      i++
    }

    // ========================================================================
    // the following replacements are global, happen once and need to happen on the entire command as-is.
    // as such, they happen outside of the above loop and last in the order of operations on the tmp variable.

    // wrap the running command with the process spawn of choice on the first iteration only
    if (
      cwin.value.allowTerminalWrap === true &&
      terminalWraps.value !== undefined &&
      terminalWraps.value[`win-${cwin.value.win}`] !== undefined
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = terminalWraps.value[`win-${cwin.value.win}`].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          tmp = wrap.replaceAll(w, tmp)
        }
      })

      if (wrap.indexOf('__PS_BASE64_ENC__') > -1) {
        tmp = wrap.replaceAll(
          '__PS_BASE64_ENC__',
          powershellEncodeBase64Command(tmp)
        )
      }
    }

    // prepend proxychains to the command if set
    const proxychainsReplacementID = `id-${cwin.value.id}-win-${cwin.value.win}`
    if (
      // allowTerminalWrap === true &&
      proxychainPrepends.value !== undefined &&
      proxychainPrepends.value[proxychainsReplacementID] !== undefined &&
      i === 0
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = proxychainPrepends.value[proxychainsReplacementID].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          tmp = wrap.replaceAll(w, tmp)
        }
      })
    }

    return tmp
  })

  const HelpTextForCommand = useMemo(() => {
    // const HelpTextForCommand = React.memo(() => {

    // this memo builds the rich help text for the given command
    if (cwin.value.help === '') {
      return (
        <Typography>
          No Help provided for this command.
          <br />
          <br /> Consider making a PR on GitHub to fix this!
        </Typography>
      )
    }

    // const newlines = cwin.value.help.split('\n')

    // const Lines = newlines.map((line, line_index) => {
    /*const Lines = () => {
      const codes = cwin.value.help.split('`')

      let i = 0
      const code_highlighted = []
      while (i < codes.length) {
        const code0 = codes[i]
        const code1 = codes[i + 1]

        const code0Lines =
          code0.indexOf('\n') < 0
            ? code0
            : code0.split('\n').map((line, line_index, thisAry) => {

              console.log('code0split', line)

              
                return (
                  <React.Fragment
                    key={`code0-line-${cwin.value.label}-${line_index}-${i}`}
                  >
                    {line}
                    {line_index + 1 < thisAry.length && (<><br /></>)}
                  </React.Fragment>
                )
              })

        const key = `cmd-code-${cwin.value.label}-${i}`

        if (code1 !== undefined) {
          const code1Lines =
            code1.indexOf('\n') < 0
              ? code1
              : code1.split('\n').map((line, line_index, thisAry) => {
                  return (
                    <React.Fragment
                      key={`code1-line-${cwin.value.label}-${line_index}-${i}`}
                    >
                      {line}
                      {line_index + 1 < thisAry.length && (<><br /></>)}

                    </React.Fragment>
                  )
                })

          if (code0.length === 0) {
            // this starts with a code block (`) is the first character
            code_highlighted.push(
              <CodeTypography key={key}>{code1Lines}</CodeTypography>
            )
            i += 2
          } else if (code0.length > 0) {
            // there is some text, a codeblock
            code_highlighted.push(
              <React.Fragment key={key}>
                {code0Lines}
                <CodeTypography>{code1Lines}</CodeTypography>
              </React.Fragment>
            )
            i += 2
          }
        } else {
          // there is some final text that is not part of a code block
          code_highlighted.push(
            <React.Fragment key={key}>{code0Lines}</React.Fragment>
          )
          i++
        }
      }

      return code_highlighted
      // return (
      //   <React.Fragment key={`cmd-line-${cwin.value.label}-${line_index}`}>
      //     {code_highlighted}
      //     <br />
      //   </React.Fragment>
      // )
      // })
    }*/

    console.log(SyntaxHighlighter.supportedLanguages.includes('shell'))

    return (
      // <Typography>
      //   {/* {Lines} */}
      //   <Lines />
      // </Typography>
      <Box
        sx={{
          background: '#111',
          padding: '15px',
          borderRadius: '5px',
          minWidth: '60vw',
          // link styles
          '& a': {
            color: '#2499ff',
          },
          '& a:visited': {
            color: '#8724ff',
          },
          // checkbox styles
          '& input[type=checkbox]': {
            position: 'relative',
            cursor: 'pointer',
            marginRight: '10px',
          },
          '& input[type=checkbox]:before': {
            content: '""',
            display: 'block',
            position: 'absolute',
            width: '20px',
            height: '20px',
            top: '0',
            left: '0',
            backgroundColor: '#e9e9e9',
          },
          '& input[type=checkbox]:checked:before': {
            // this is the box behind the check symbol
            content: '""',
            display: 'block',
            position: 'absolute',
            width: '20px',
            height: '20px',
            top: '0',
            left: '0',
            backgroundColor: '#1E80EF',
          },
          '& input[type=checkbox]:checked:after': {
            // this is the check symbol in the box
            content: '""',
            display: 'block',
            width: '5px',
            height: '10px',
            border: 'solid white',
            borderWidth: '0 2px 2px 0',
            transform: 'rotate(45deg)',
            position: 'absolute',
            padding: '2px',
            top: '4px',
            left: '8px',
            marginRight: '4px',
          },
          // table styles:
          '& table': {
            backgroundColor: '#333',
            fontSize: '16px',
            borderCollapse: 'collapse',
          },
          '& table th': {
            backgroundColor: '#222',
            border: '2px solid #8f8f8f',

            padding: '10px',
          },
          '& table td': {
            border: '2px solid #8f8f8f',
            padding: '8px',
          },
          // inline code blocks, not the syntax highlighted ones
          '& p > code, & pre > code': {
            padding: '2px 4px',
            borderRadius: '2px',
            background: '#1d2021',
            fontFamily: 'monospace',
          },
          '& pre > code': {
            display: 'block',
            padding: '16px',
            borderRadius: '5px',
          },
          // blockquotes
          '& blockquote': {
            borderLeft: '4px solid #333',
            color: '#eee',
            paddingLeft: '25px',
            marginLeft: '5px',
          },
        }}
      >
        <Markdown
          remarkPlugins={[[remarkGfm]]}
          children={cwin.value.help}
          components={{
            code(props) {
              const {
                children,
                className,
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                node,
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                ref,
                ...rest
              } = props
              const match = /language-(\w+)/.exec(className || '')
              return match ? (
                <SyntaxHighlighter
                  {...rest}
                  PreTag="div"
                  showLineNumbers
                  children={String(children).replace(/\n$/, '')}
                  language={match[1]}
                  style={syntaxHighlightingStyle}
                />
              ) : (
                <code {...rest} className={className}>
                  {children}
                </code>
              )
            },
          }}
        />
      </Box>
    )
  }, [cwin.value.help])
  // })

  useSignalEffect(() => {
    const rep = cmdText.value

    // check if a warning to the user about unreplaced values is necessary
    const re = new RegExp('__[A-Za-z0-9_]*__')

    displayUnreplacedValueWarning.value = re.test(rep)

    // flash tooltip that the component updated
    updateStatus.value = true
    const timer1 = setTimeout(() => {
      updateStatus.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  })

  return (
    <Box
      key={`window-${cwin.value.win}`}
      sx={{ borderBottom: '1px solid #cecece' }}
    >
      <SuccessTooltip
        open={updateStatus.value}
        title="Updated!"
        placement="left"
      >
        <Typography variant="h5">
          {displayUnreplacedValueWarning.value === true && (
            <AlertDialog
              title="Warning: Possibly unreplaced values"
              CustomIcon={<WarningIcon color="warning" />}
            >
              <Typography>
                If the command-to-run has unreplaced values, then it's not
                expected to function correctly. Ensure the command has the
                values expected before attempting to run!
                <br />
                <br />
                NOTE: the Warning Icon will disappear when the command-to-run
                has all replacement values matching the{' '}
                <CodeTypography>__VALUE_NAME__</CodeTypography> pattern
                replaced.
              </Typography>
            </AlertDialog>
          )}
          <AlertDialog title={`Help: ${cwin.value.label}`}>
            {HelpTextForCommand}
            {/* <HelpTextForCommand /> */}
          </AlertDialog>
          {cwin.value.label} - Window {cwin.value.win} Platform:
          {cwin.value.platform}
        </Typography>
      </SuccessTooltip>

      <CopyItem val={cmdText.value}>
        <Typography
          variant="caption"
          sx={{
            fontFamily: 'monospace',
            background: '#000',
            padding: '10px',
            borderRadius: '5px',
            margin: '10px 20px 10px 10px',
            maxWidth: '90%',
            overflowWrap: 'break-word',
            userSelect: 'none',
            // overflowX: 'scroll'
          }}
        >
          {cmdText.value}
        </Typography>
      </CopyItem>
    </Box>
  )
})

export default CommandText
