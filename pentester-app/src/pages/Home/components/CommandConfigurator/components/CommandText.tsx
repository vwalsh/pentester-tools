import { Box, Typography } from '@mui/material'

import React, { useCallback, useContext, useEffect, useMemo } from 'react'
import CopyItem from '../../../../../components/CopyItem'
import { CommandWindowsProps } from '../../ConfigInput/ConfigInput'
import { AppState } from '../../../Home'
import { useComputed, useSignal, useSignalEffect } from '@preact/signals-react'
import SuccessTooltip from '../../../../../components/SuccessTooltip'
import WarningIcon from '@mui/icons-material/Warning'
import AlertDialog from '../../../../../components/AlertDialog'
import CodeTypography from '../../../../../components/CodeTypography'
import RenderMarkdown from '../../../../../components/RenderMarkdown'
import { globalReplacements } from '../../../../NewCommandBuilder/dataStructures'
import { BooleanDict } from '../../../../../signals/signals'

import { path as HTTPToolsFilesPath } from '../../../../../assets/dirtree.json'

interface CommandTextProps {
  windowNum: number
}

const CommandText = React.memo(({ windowNum }: CommandTextProps) => {
  const {
    ahost,
    aport,
    httpFile,
    replacements,
    terminalWraps,
    proxychainPrepends,
    command_windows,
    vhost,
    vport,
    loot,

    addCommandHistory,
    updateReplacedValues,
  } = useContext(AppState)

  const cmdText = useSignal<string>('')

  const updateStatus = useSignal<boolean>(false)
  const displayUnreplacedValueWarning = useSignal<boolean>(false)

  const powershellEncodeBase64Command = useCallback((cmd: string): string => {
    const encoder = new TextEncoder()
    const encoded = encoder.encode(cmd)
    let binaryString = ''
    const nullString = String.fromCharCode(0)
    encoded.forEach((byte) => {
      binaryString += String.fromCharCode(byte) + nullString
    })
    return btoa(binaryString)
  }, [])

  const cwin = useComputed((): CommandWindowsProps => {
    return command_windows.value[windowNum]
  })

  useEffect(() => {
    if (
      ahost.value === undefined ||
      aport.value === undefined ||
      httpFile.value === undefined ||
      cwin.value === undefined ||
      cwin.value.cmd === undefined ||
      powershellEncodeBase64Command === undefined ||
      updateReplacedValues === undefined
    ) {
      return
    }

    const commandIdentifier = `id-${cwin.value.id}-win-${cwin.value.win}`
    const replaced: BooleanDict = {}

    // global replacement values (for tools in the global section at the top of the page)
    const httpPath = httpFile.value.split('/')
    const httpFileName = httpPath.pop()
    const httpRootPath = httpPath.join('/')
    const globalReplaceValues = [
      { replace: '__ATTACKER_HOST__', value: ahost.value },
      { replace: '__ATTACKER_PORT__', value: aport.value.toString() },
      { replace: '__TARGET_HOST__', value: vhost.value },
      { replace: '__TARGET_PORT__', value: vport.value.toString() },
      { replace: '/__PATH__', value: httpRootPath },
      {
        replace: '__FILE__',
        value: httpFileName !== undefined ? httpFileName : '',
      },
      { replace: '__TOOLS_PATH__', value: HTTPToolsFilesPath },
    ]

    let tmp = cwin.value.cmd
    let lastTmp = tmp
    let i = 0
    const max = 10 // max times to loop
    while (i < max && tmp.indexOf('__') > -1) {
      // to ensure layered/cascaded values get replaced properly, run this code a few times
      // loop until the max number of times OR if it appears no more replacement values exist

      for (const obj of globalReplaceValues) {
        // test that the dataStructure GlobalReplacements is in sync with this structure.
        const f = globalReplacements.filter(
          (globalObj) => globalObj.replace === obj.replace
        )
        if (f.length < 1) {
          throw new Error(
            'ERROR: globalReplacements in dataStructures.ts is out of sync with globalReplaceValues in CommandText.tsx'
          )
        }

        // replace the global values in the tmp var as they exist
        if (tmp.indexOf(obj.replace) > -1) {
          replaced[`${commandIdentifier}-${obj.replace}`] = true

          tmp = tmp.replaceAll(obj.replace, obj.value)
        }
      }

      // replace all of the config set properties
      if (replacements.value !== undefined) {
        Object.keys(replacements.value).forEach(function (key) {
          if (tmp.indexOf(key) > -1) {
            replaced[`${commandIdentifier}-${key}`] = true

            tmp = tmp.replaceAll(key, replacements.value[key].toString())
          }
        })
      }

      // replace all of the __LOOT_*__ vars being used
      Object.keys(loot.value).forEach(function (key) {
        if (tmp.indexOf(key) > -1) {
          replaced[`${commandIdentifier}-${key}`] = true

          tmp = tmp.replaceAll(key, replacements.value[key].toString())
        }
      })

      if (lastTmp === tmp) {
        // exit, no replacements are happening
        i = max
      }

      lastTmp = tmp
      i++
    }
    // === loop end
    //
    // ========================================================================
    // the following replacements are global, happen once and need to happen on the entire command as-is.
    // as such, they happen outside of the above loop and last in the order of operations on the tmp variable.

    // wrap the running command with the process spawn of choice on the first iteration only
    if (
      cwin.value.allowTerminalWrap === true &&
      terminalWraps.value !== undefined &&
      terminalWraps.value[`win-${cwin.value.win}`] !== undefined
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = terminalWraps.value[`win-${cwin.value.win}`].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          replaced[`${commandIdentifier}-${w}`] = true

          tmp = wrap.replaceAll(w, tmp)
        }
      })

      if (wrap.indexOf('__PS_BASE64_ENC__') > -1) {
        replaced[`${commandIdentifier}-__PS_BASE64_ENC__`] = true

        tmp = wrap.replaceAll(
          '__PS_BASE64_ENC__',
          powershellEncodeBase64Command(tmp)
        )
      }

      if (wrap.indexOf('__BASE64_CMD__') > -1) {
        // base64 encode the command into the wrap
        replaced[`${commandIdentifier}-__BASE64_CMD__`] = true

        tmp = wrap.replaceAll('__BASE64_CMD__', btoa(tmp))
      }
    }

    // prepend proxychains to the command if set
    if (
      cwin.value.allowProxychains === true &&
      proxychainPrepends.value !== undefined &&
      proxychainPrepends.value[commandIdentifier] !== undefined
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = proxychainPrepends.value[commandIdentifier].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          replaced[`${commandIdentifier}-${w}`] = true

          tmp = wrap.replaceAll(w, tmp)
        }
      })
    }

    updateReplacedValues(commandIdentifier, replaced)

    cmdText.value = tmp
  }, [
    ahost.value,
    aport.value,
    cmdText,
    cwin.value,
    httpFile.value,
    loot.value,
    powershellEncodeBase64Command,
    proxychainPrepends.value,
    replacements.value,
    terminalWraps.value,
    updateReplacedValues,
    vhost.value,
    vport.value,
  ])

  const markdownText = useComputed((): string => {
    // linux bash by default
    let highlightLang: 'bash' | 'powershell' | 'batch' = 'bash'

    if (cwin.value.platform.indexOf('linux') < 0) {
      // not linux, assuming windows. if mac gets added then this will fail.
      if (cwin.value.terminal.indexOf('ps') > -1) {
        // default to powershell
        highlightLang = 'powershell'
      } else {
        highlightLang = 'batch'
      }
    }

    return '```' + highlightLang + '\n' + cmdText.value + '\n```'
  })

  const HelpTextForCommand = useMemo(() => {
    // this memo builds the rich help text for the given command
    if (cwin.value.help === '') {
      return (
        <Typography>
          No Help provided for this command.
          <br />
          <br /> Consider making a PR on GitHub to fix this!
        </Typography>
      )
    }

    return <RenderMarkdown mdText={cwin.value.help} />
  }, [cwin.value.help])

  useSignalEffect(() => {
    const rep = cmdText.value

    // check if a warning to the user about unreplaced values is necessary
    const re = new RegExp('__[A-Za-z0-9_]*__')

    displayUnreplacedValueWarning.value = re.test(rep)

    // flash tooltip that the component updated
    updateStatus.value = true
    const timer1 = setTimeout(() => {
      updateStatus.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  })

  return (
    <Box
      key={`window-${cwin.value.win}`}
      sx={{
        borderBottom: '1px solid #cecece',
        maxWidth: '100%',
        paddingTop: '20px',
      }}
    >
      <SuccessTooltip
        open={updateStatus.value}
        title="Updated!"
        placement="left"
      >
        <Box sx={{ display: 'flex' }}>
          {displayUnreplacedValueWarning.value === true && (
            <AlertDialog
              title="Warning: Possibly unreplaced values"
              CustomIcon={<WarningIcon color="warning" />}
            >
              <Typography>
                If the command-to-run has unreplaced values, then it's not
                expected to function correctly. Ensure the command has the
                values expected before attempting to run!
                <br />
                <br />
                NOTE: the Warning Icon will disappear when the command-to-run
                has all replacement values matching the{' '}
                <CodeTypography>__VALUE_NAME__</CodeTypography> pattern
                replaced.
              </Typography>
            </AlertDialog>
          )}
          <AlertDialog title={`Help: ${cwin.value.label}`}>
            {HelpTextForCommand}
          </AlertDialog>

          <Box>
            <Typography
              variant="h5"
              sx={{
                fontStyle: 'italic',
                textTransform: 'capitalize',
                color: '#666',
              }}
            >
              {cwin.value.id.replaceAll('-', ' ')}
              <Typography variant="caption">
                {' '}
                - Window {cwin.value.win} Platform: {cwin.value.platform}
              </Typography>
            </Typography>
            <Typography variant="h5">{cwin.value.label}</Typography>
          </Box>
        </Box>
      </SuccessTooltip>

      <CopyItem
        val={cmdText.value}
        onClick={() => {
          addCommandHistory(cmdText.value)
        }}
      >
        {/* choose to render the command with syntax highlighting for either BASH or POWERSHELL */}
        <RenderMarkdown showLineNumbers={false} mdText={markdownText.value} />
        {/* this is the old way of displaying the command-to-run. remove this after syntax highlighting is tested longer. */}
        {/* <Typography
          variant="caption"
          sx={{
            fontFamily: 'monospace',
            background: '#000',
            padding: '10px',
            borderRadius: '5px',
            margin: '10px 20px 10px 10px',
            maxWidth: '90%',
            overflowWrap: 'break-word',
            userSelect: 'none',
            // overflowX: 'scroll'
          }}
        >
          {cmdText.value}
        </Typography> */}
      </CopyItem>
    </Box>
  )
})

export default CommandText
