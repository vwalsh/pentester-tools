import { Box, Typography } from '@mui/material'

import React, { useCallback, useContext, useMemo } from 'react'
import CopyItem from '../../../../../components/CopyItem'
import { CommandWindowsProps } from '../../ConfigInput/ConfigInput'
import { AppState } from '../../../Home'
import { useComputed, useSignal, useSignalEffect } from '@preact/signals-react'
import SuccessTooltip from '../../../../../components/SuccessTooltip'
import WarningIcon from '@mui/icons-material/Warning'
import AlertDialog from '../../../../../components/AlertDialog'
import CodeTypography from '../../../../../components/CodeTypography'
import RenderMarkdown from '../../../../../components/RenderMarkdown'

interface CommandTextProps {
  windowNum: number
}

const CommandText = React.memo(({ windowNum }: CommandTextProps) => {
  const {
    ahost,
    aport,
    httpFile,
    replacements,
    terminalWraps,
    proxychainPrepends,
    command_windows,
    vhost,
    vport,
    loot,
    addCommandHistory,
  } = useContext(AppState)

  const updateStatus = useSignal<boolean>(false)
  const displayUnreplacedValueWarning = useSignal<boolean>(false)

  const powershellEncodeBase64Command = useCallback((cmd: string): string => {
    const encoder = new TextEncoder()
    const encoded = encoder.encode(cmd)
    let binaryString = ''
    const nullString = String.fromCharCode(0)
    encoded.forEach((byte) => {
      binaryString += String.fromCharCode(byte) + nullString
    })
    return btoa(binaryString)
  }, [])

  const cwin = useComputed((): CommandWindowsProps => {
    return command_windows.value[windowNum]
  })

  const cmdText = useComputed((): string => {
    if (
      ahost.value === undefined ||
      aport.value === undefined ||
      httpFile.value === undefined ||
      cwin.value === undefined ||
      cwin.value.cmd === undefined
    ) {
      return ''
    }

    let tmp = cwin.value.cmd
    let i = 0
    while (i < 2) {
      // to ensure layered/cascaded values get replaced properly, run this code a few times
      tmp = tmp.replaceAll('__ATTACKER_HOST__', ahost.value)
      tmp = tmp.replaceAll('__ATTACKER_PORT__', aport.value.toString())

      tmp = tmp.replaceAll('__TARGET_HOST__', vhost.value)
      tmp = tmp.replaceAll('__TARGET_PORT__', vport.value.toString())

      const httpPath = httpFile.value.split('/')
      const httpFileName = httpPath.pop()
      const httpRootPath = httpPath.join('/')

      tmp = tmp.replaceAll('/__PATH__', httpRootPath)
      tmp = tmp.replaceAll(
        '__FILE__',
        httpFileName !== undefined ? httpFileName : ''
      )

      // replace all of the config set properties
      if (replacements.value !== undefined) {
        Object.keys(replacements.value).forEach(function (key) {
          tmp = tmp.replaceAll(key, replacements.value[key].toString())
        })
      }

      // replace all of the __LOOT_*__ vars being used
      Object.keys(loot.value).forEach(function (key) {
        tmp = tmp.replaceAll(key, loot.value[key].toString())
      })

      i++
    }

    // ========================================================================
    // the following replacements are global, happen once and need to happen on the entire command as-is.
    // as such, they happen outside of the above loop and last in the order of operations on the tmp variable.

    // wrap the running command with the process spawn of choice on the first iteration only
    if (
      cwin.value.allowTerminalWrap === true &&
      terminalWraps.value !== undefined &&
      terminalWraps.value[`win-${cwin.value.win}`] !== undefined
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = terminalWraps.value[`win-${cwin.value.win}`].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          tmp = wrap.replaceAll(w, tmp)
        }
      })

      if (wrap.indexOf('__PS_BASE64_ENC__') > -1) {
        tmp = wrap.replaceAll(
          '__PS_BASE64_ENC__',
          powershellEncodeBase64Command(tmp)
        )
      }

      if (wrap.indexOf('__BASE64_CMD__') > -1) {
        // base64 encode the command into the wrap
        tmp = wrap.replaceAll('__BASE64_CMD__', btoa(tmp))
      }
    }

    // prepend proxychains to the command if set
    const proxychainsReplacementID = `id-${cwin.value.id}-win-${cwin.value.win}`
    if (
      // allowTerminalWrap === true &&
      proxychainPrepends.value !== undefined &&
      proxychainPrepends.value[proxychainsReplacementID] !== undefined &&
      i === 0
    ) {
      // TODO: extend these options with each addition to the CommandWrap array
      const wrapOptions = ['__CMD__']
      const wrap = proxychainPrepends.value[proxychainsReplacementID].toString()

      wrapOptions.forEach((w) => {
        if (wrap.indexOf(w) > -1) {
          tmp = wrap.replaceAll(w, tmp)
        }
      })
    }

    return tmp
  })

  const HelpTextForCommand = useMemo(() => {
    // this memo builds the rich help text for the given command
    if (cwin.value.help === '') {
      return (
        <Typography>
          No Help provided for this command.
          <br />
          <br /> Consider making a PR on GitHub to fix this!
        </Typography>
      )
    }

    return <RenderMarkdown mdText={cwin.value.help} />
  }, [cwin.value.help])

  useSignalEffect(() => {
    const rep = cmdText.value

    // check if a warning to the user about unreplaced values is necessary
    const re = new RegExp('__[A-Za-z0-9_]*__')

    displayUnreplacedValueWarning.value = re.test(rep)

    // flash tooltip that the component updated
    updateStatus.value = true
    const timer1 = setTimeout(() => {
      updateStatus.value = false
    }, 500)
    return () => {
      clearTimeout(timer1)
    }
  })

  return (
    <Box
      key={`window-${cwin.value.win}`}
      sx={{ borderBottom: '1px solid #cecece', maxWidth: '100%' }}
    >
      <SuccessTooltip
        open={updateStatus.value}
        title="Updated!"
        placement="left"
      >
        <Typography variant="h5">
          {displayUnreplacedValueWarning.value === true && (
            <AlertDialog
              title="Warning: Possibly unreplaced values"
              CustomIcon={<WarningIcon color="warning" />}
            >
              <Typography>
                If the command-to-run has unreplaced values, then it's not
                expected to function correctly. Ensure the command has the
                values expected before attempting to run!
                <br />
                <br />
                NOTE: the Warning Icon will disappear when the command-to-run
                has all replacement values matching the{' '}
                <CodeTypography>__VALUE_NAME__</CodeTypography> pattern
                replaced.
              </Typography>
            </AlertDialog>
          )}
          <AlertDialog title={`Help: ${cwin.value.label}`}>
            {HelpTextForCommand}
          </AlertDialog>
          {cwin.value.label} - Window {cwin.value.win} Platform:
          {cwin.value.platform}
        </Typography>
      </SuccessTooltip>

      <CopyItem
        val={cmdText.value}
        onClick={() => {
          addCommandHistory(cmdText.value)
        }}
      >
        {/* choose to render the command with syntax highlighting for either BASH or POWERSHELL */}
        <RenderMarkdown
          showLineNumbers={false}
          mdText={
            '```' +
            (cwin.value.platform.indexOf('linux') > -1
              ? 'bash'
              : 'powershell') +
            '\n' +
            cmdText.value +
            '\n```'
          }
        />
        {/* this is the old way of displaying the command-to-run. remove this after syntax highlighting is tested longer. */}
        {/* <Typography
          variant="caption"
          sx={{
            fontFamily: 'monospace',
            background: '#000',
            padding: '10px',
            borderRadius: '5px',
            margin: '10px 20px 10px 10px',
            maxWidth: '90%',
            overflowWrap: 'break-word',
            userSelect: 'none',
            // overflowX: 'scroll'
          }}
        >
          {cmdText.value}
        </Typography> */}
      </CopyItem>
    </Box>
  )
})

export default CommandText
